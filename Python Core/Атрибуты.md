# Атрибуты

<details>
  <summary>__dict__</summary>

`[Атрибут __dict__]` - в Python представляет собой словарь, который содержит все атрибуты объекта в виде пар ключ-значение. Для функций __dict__ будет пустым, если функции не присвоены дополнительные атрибуты.

<details>
  <summary>Пример испоьзования с функцией</summary>

Для обычной функции __dict__ возвращает пустой словарь, если не добавлять в функцию атрибуты динамически.
```
def greet():
    pass

print(greet.__dict__)  # Вывод: {}

greet.cust = 'Присвоение функции greet нового атрибута cust'

print(greet.__dict__)   # Вывод: {'cust': 'Присвоение функции greet нового атрибута cust'}

greet.new_cast = 'Присвоение функции greet еще одного атрибута new_cust'

print(greet.__dict__)   # Вывод: {'cust': 'Присвоение функции greet нового атрибута cust', 'new_cast': 'Присвоение функции greet еще одного атрибута new_cust'}

Общий вывод:

{}
{'cust': 'Присвоение функции greet нового атрибута cust'}
{'cust': 'Присвоение функции greet нового атрибута cust', 'new_cast': 'Присвоение функции greet еще одного атрибута new_cust'}
```
В первом выводеБ так как у функции greet нет дополнительных атрибутов, __dict__ возвращает пустой словарь.  
Далее к функции добавляются два дополнительных атрибута, которые выводятся на печать.
#

</details>
<details>
  <summary>Пример испоьзования с декоратором</summary>

Декораторы могут модифицировать функции, добавляя или изменяя их атрибуты, что отразится в __dict__.
```
def my_decorator(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result

    # Устанавливаем атрибуты на wrapper, а не на func
    wrapper.ferst_attr = ''
    wrapper.custom_attr = "Decorated function"
    return wrapper


@my_decorator
def greet():
    pass


print(greet.__dict__)  # Вывод: {'custom_attr': 'Decorated function'}

Вывод: {'ferst_attr': '', 'custom_attr': 'Decorated function'}
```
Для сохрания атрибутов на уровне декорированной функции, нужно установливать их на обёртке (`wrapper`), которую возвращает декоратор (`my_decorator`).


#

</details>
<details>
  <summary>Пример испоьзования с рекурсией</summary>

В рекурсивных функциях __dict__ также может быть использован для хранения дополнительных данных. Значения атрибутов функции остаются одинаковыми для всех рекурсивных вызовов, так как сами вызовы не меняют атрибуты функции.
```
def factorial(n, acc=1):
    if not hasattr(factorial, 'call_count'):
        factorial.call_count = 0
    factorial.call_count += 1

    print(f"Function __dict__: {factorial.__dict__}")

    if n == 0:
        return acc
    else:
        return factorial(n - 1, acc * n)


factorial(3)

Вывод:

Function __dict__: {'call_count': 1}
Function __dict__: {'call_count': 2}
Function __dict__: {'call_count': 3}
Function __dict__: {'call_count': 4}
```

### Разбор кода  

1. Проверка и установка атрибута call_count:
```
if not hasattr(factorial, 'call_count'):
    factorial.call_count = 0
```
- Проверяет наличие атрибута call_count у функции factorial.
- Если атрибут не существует, он создаётся и устанавливается в 0. Это нужно для инициализации счётчика вызовов функции.

2. Увеличение счётчика вызовов:
```
factorial.call_count += 1
```
- Каждый раз при вызове функции значение call_count увеличивается на 1. Это позволяет отслеживать количество вызовов функции.

3. Вывод атрибутов функции:
```
print(f"Function __dict__: {factorial.__dict__}")
```
- Печатает словарь атрибутов функции factorial, показывая текущее значение call_count и другие потенциальные атрибуты функции.

4. Условие базового случая и рекурсия:
```
if n == 0:
    return acc
else:
    return factorial(n - 1, acc * n)
```
- Базовый случай: Если n равно 0, функция возвращает текущее значение acc. Это завершает рекурсию.
- Рекурсия: Если n не равно 0, функция вызывает себя с n - 1 и acc * n. Это происходит до тех пор, пока n не станет 0.

5. Вызов функции:
```
factorial(3)
```
- Запускает вычисление факториала числа 3. Функция будет рекурсивно вызываться до тех пор, пока n не достигнет 0.

#

</details>

#

</details>










<details>
  <summary>__name__</summary>

`[Атрибут __name__]` - хранит имя функции в виде строки.  

<details>
  <summary>Пример испоьзования с функцией</summary>

```
def greet():
    print("Hello!")

print(greet.__name__)  # Вывод: greet
```

#

</details>
<details>
  <summary>Пример испоьзования с декоратором</summary>

Декораторы часто изменяют функции. Чтобы сохранить оригинальное имя функции, часто используются атрибуты __name__ и __doc__ внутри декоратора.

```
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Calling function: {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()  # Вывод: Calling function: say_hello
             # Hello!
```
В этом примере декоратор my_decorator использует func.__name__, чтобы напечатать имя оригинальной функции перед её вызовом.


#

</details>
<details>
  <summary>Пример испоьзования с рекурсией</summary>

При рекурсивном вызове функции __name__ будет указывать на имя функции, так как оно сохраняется в каждом вызове.

```
def factorial(n):
    if n == 0:
        return 1
    else:
        print(f"Calling factorial: {factorial.__name__} with n={n}")
        return n * factorial(n - 1)

print(factorial(3))  # Вывод: Calling factorial: factorial with n=3
                     # Calling factorial: factorial with n=2
                     # Calling factorial: factorial with n=1
                     # Calling factorial: factorial with n=0
                     # 6
```
Здесь factorial.__name__ будет всегда "factorial", даже в рекурсивных вызовах. Это может быть полезно для отслеживания вызовов функций в рекурсивных алгоритмах.

Если нужны дополнительные пояснения, дай знать!

#

</details>


#

</details>














<details>
  <summary>__doc__</summary>

`[Атрибут __doc__]` - хранит строку документации (docstring) для объектов Python, таких как модули, классы, методы и функции. Строка документации описывает назначение и использование объекта и помогает разработчикам понимать код.


  

<details>
  <summary>Пример испоьзования с функцией</summary>

```
def add(a, b):
    """
    Эта функция складывает два числа и возвращает результат.
    :param a: Первое число
    :param b: Второе число
    :return: Сумма чисел a и b
    """
    return a + b

# Вывод строки документации
print(add.__doc__)
```
Вывод:
```
Эта функция складывает два числа и возвращает результат.
:param a: Первое число
:param b: Второе число
:return: Сумма чисел a и b

```

#

</details>
<details>
  <summary>Пример испоьзования с декоратором</summary>

```
def my_decorator(func):
    """
    Декоратор, который оборачивает функцию.
    """
    def wrapper(*args, **kwargs):
        """
        Обертка декоратора.
        """
        print("Перед вызовом функции.")
        result = func(*args, **kwargs)
        print("После вызова функции.")
        return result
    return wrapper

@my_decorator
def say_hello(name):
    """
    Функция приветствия.
    :param name: Имя человека
    """
    print(f"Привет, {name}!")

# Вывод строки документации
print(say_hello.__doc__)
```
Вывод:
```
Функция приветствия.
:param name: Имя человека
```

#

</details>
<details>
  <summary>Пример испоьзования с рекурсией</summary>

```
def factorial(n):
    """
    Вычисляет факториал числа n.
    :param n: Число
    :return: Факториал числа n
    """
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

# Вывод строки документации
print(factorial.__doc__)
```
Вывод:
```
Вычисляет факториал числа n.
:param n: Число
:return: Факториал числа n
```

#

</details>

#

</details>









<details>
  <summary>__defaults__</summary>

`[Атрибут __defaults__]` -  в Python хранит значения по умолчанию для параметров функции. Он представляет собой кортеж, где каждый элемент соответствует значению по умолчанию для параметра в функции. Если функция не имеет параметров с значениями по умолчанию, этот атрибут будет равен None.


<details>
  <summary>Пример испоьзования с функцией</summary>
  
При определении функции, значения по умолчанию для параметров хранятся в __defaults__.
```
def greet(name="World"):
    return f"Hello, {name}!"

print(greet.__defaults__)  # Вывод: ('World',)
```
В этом примере greet.__defaults__ содержит кортеж с одним элементом 'World', который является значением по умолчанию для параметра name.

#

</details>
<details>
  <summary>Пример испоьзования с декоратором</summary>

Декораторы могут изменять функции, и для сохранения значений по умолчанию декоратор может использовать __defaults__.

```
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Function defaults: {func.__defaults__}")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet(name="World"):
    return f"Hello, {name}!"

greet()  # Вывод: Function defaults: ('World',)
```

#

</details>
<details>
  <summary>Пример испоьзования с рекурсией</summary>

В рекурсивных функциях атрибут __defaults__ остается неизменным для всех рекурсивных вызовов, так как он хранит значения по умолчанию, определенные при создании функции.

```
def factorial(n, acc=1, bcc=2, ccc=3):
    print(f"Function defaults: {factorial.__defaults__}")
    if n == 0:
        return acc
    else:
        return factorial(n - 1, acc * n, bcc * n, ccc * 3)

factorial(3)   # Function defaults: (1, 2, 3)
               # Function defaults: (1, 2, 3)
               # Function defaults: (1, 2, 3)
               # Function defaults: (1, 2, 3)
```
В этом примере factorial.__defaults__ будет содержать кортеж (1,), представляющий значение по умолчанию для параметра acc. Это значение остается неизменным во всех рекурсивных вызовах функции.

#

</details>

#

</details>












<details>
  <summary>Null</summary>



</details>
