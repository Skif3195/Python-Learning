# Атрибуты

<details>
  <summary>__dict__</summary>

`[Атрибут __dict__]` представляет собой словарь, содержащий все атрибуты (переменные и методы) объекта. Он особенно полезен для классов и экземпляров классов, так как позволяет просматривать и изменять их содержимое.


<details>
  <summary>Пример испоьзования с функцией</summary>

```
def add(a, b):
    return a + b

# Вывод атрибутов функции
print(add.__dict__)

# Добавление нового атрибута
add.description = "Функция для сложения двух чисел."
print(add.__dict__)
```
Вывод:
```
{}
{'description': 'Функция для сложения двух чисел.'}
```

#

</details>
<details>
  <summary>Пример испоьзования с декоратором</summary>

```
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print("Перед вызовом функции.")
        result = func(*args, **kwargs)
        print("После вызова функции.")
        return result
    return wrapper

@my_decorator
def say_hello(name):
    print(f"Привет, {name}!")

# Вывод атрибутов функции
print(say_hello.__dict__)

# Добавление нового атрибута
say_hello.description = "Функция приветствия, обернутая декоратором."
print(say_hello.__dict__)
```
Вывод:
```
{}
{'description': 'Функция приветствия, обернутая декоратором.'}
```

#

</details>
<details>
  <summary>Пример испоьзования с рекурсией</summary>

```
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

# Вывод атрибутов функции
print(factorial.__dict__)

# Добавление нового атрибута
factorial.description = "Функция для вычисления факториала числа."
print(factorial.__dict__)
```
Вывод:
```
{}
{'description': 'Функция для вычисления факториала числа.'}
```

#

</details>

#

</details>










<details>
  <summary>__name__</summary>

`[Атрибут __name__]` - хранит имя функции в виде строки.  

<details>
  <summary>Пример испоьзования с функцией</summary>

```
def greet():
    print("Hello!")

print(greet.__name__)  # Вывод: greet
```

#

</details>
<details>
  <summary>Пример испоьзования с декоратором</summary>

Декораторы часто изменяют функции. Чтобы сохранить оригинальное имя функции, часто используются атрибуты __name__ и __doc__ внутри декоратора.

```
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Calling function: {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()  # Вывод: Calling function: say_hello
             # Hello!
```
В этом примере декоратор my_decorator использует func.__name__, чтобы напечатать имя оригинальной функции перед её вызовом.


#

</details>
<details>
  <summary>Пример испоьзования с рекурсией</summary>

При рекурсивном вызове функции __name__ будет указывать на имя функции, так как оно сохраняется в каждом вызове.

```
def factorial(n):
    if n == 0:
        return 1
    else:
        print(f"Calling factorial: {factorial.__name__} with n={n}")
        return n * factorial(n - 1)

print(factorial(3))  # Вывод: Calling factorial: factorial with n=3
                     # Calling factorial: factorial with n=2
                     # Calling factorial: factorial with n=1
                     # Calling factorial: factorial with n=0
                     # 6
```
Здесь factorial.__name__ будет всегда "factorial", даже в рекурсивных вызовах. Это может быть полезно для отслеживания вызовов функций в рекурсивных алгоритмах.

Если нужны дополнительные пояснения, дай знать!

#

</details>


#

</details>














<details>
  <summary>__doc__</summary>

`[Атрибут __doc__]` - хранит строку документации (docstring) для объектов Python, таких как модули, классы, методы и функции. Строка документации описывает назначение и использование объекта и помогает разработчикам понимать код.


  

<details>
  <summary>Пример испоьзования с функцией</summary>

```
def add(a, b):
    """
    Эта функция складывает два числа и возвращает результат.
    :param a: Первое число
    :param b: Второе число
    :return: Сумма чисел a и b
    """
    return a + b

# Вывод строки документации
print(add.__doc__)
```
Вывод:
```
Эта функция складывает два числа и возвращает результат.
:param a: Первое число
:param b: Второе число
:return: Сумма чисел a и b

```

#

</details>
<details>
  <summary>Пример испоьзования с декоратором</summary>

```
def my_decorator(func):
    """
    Декоратор, который оборачивает функцию.
    """
    def wrapper(*args, **kwargs):
        """
        Обертка декоратора.
        """
        print("Перед вызовом функции.")
        result = func(*args, **kwargs)
        print("После вызова функции.")
        return result
    return wrapper

@my_decorator
def say_hello(name):
    """
    Функция приветствия.
    :param name: Имя человека
    """
    print(f"Привет, {name}!")

# Вывод строки документации
print(say_hello.__doc__)
```
Вывод:
```
Функция приветствия.
:param name: Имя человека
```

#

</details>
<details>
  <summary>Пример испоьзования с рекурсией</summary>

```
def factorial(n):
    """
    Вычисляет факториал числа n.
    :param n: Число
    :return: Факториал числа n
    """
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

# Вывод строки документации
print(factorial.__doc__)
```
Вывод:
```
Вычисляет факториал числа n.
:param n: Число
:return: Факториал числа n
```

#

</details>

#

</details>









<details>
  <summary>__defaults__</summary>

`[Атрибут __defaults__]` -  в Python хранит значения по умолчанию для параметров функции. Он представляет собой кортеж, где каждый элемент соответствует значению по умолчанию для параметра в функции. Если функция не имеет параметров с значениями по умолчанию, этот атрибут будет равен None.


<details>
  <summary>Пример испоьзования с функцией</summary>
  
При определении функции, значения по умолчанию для параметров хранятся в __defaults__.
```
def greet(name="World"):
    return f"Hello, {name}!"

print(greet.__defaults__)  # Вывод: ('World',)
```
В этом примере greet.__defaults__ содержит кортеж с одним элементом 'World', который является значением по умолчанию для параметра name.

#

</details>
<details>
  <summary>Пример испоьзования с декоратором</summary>

Декораторы могут изменять функции, и для сохранения значений по умолчанию декоратор может использовать __defaults__.

```
def my_decorator(func):
    def wrapper(*args, **kwargs):
        print(f"Function defaults: {func.__defaults__}")
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def greet(name="World"):
    return f"Hello, {name}!"

greet()  # Вывод: Function defaults: ('World',)
```

#

</details>
<details>
  <summary>Пример испоьзования с рекурсией</summary>

В рекурсивных функциях атрибут __defaults__ остается неизменным для всех рекурсивных вызовов, так как он хранит значения по умолчанию, определенные при создании функции.

```
def factorial(n, acc=1):
    print(f"Function defaults: {factorial.__defaults__}")
    if n == 0:
        return acc
    else:
        return factorial(n - 1, acc * n)

factorial(3)   # Function defaults: (1,)
               # Function defaults: (1,)
               # Function defaults: (1,)
               # Function defaults: (1,)
```
В этом примере factorial.__defaults__ будет содержать кортеж (1,), представляющий значение по умолчанию для параметра acc. Это значение остается неизменным во всех рекурсивных вызовах функции.

#

</details>

#

</details>












<details>
  <summary>Null</summary>



</details>
