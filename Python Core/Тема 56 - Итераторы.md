# Итераторы

`[Итерируемый объект`] - объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом.  

Существует два типа итерируемых объектов:

1. Итераторы
2. Коллекции и последовательности


Итераторы

`[Итератор]` — специальный объект, который выдает свои элементы по одному за раз.  
`[next()]` - возвращает следующий элемент из последовательности. Когда элементы заканчиваются, метод должен вызывать исключение StopIteration.
```
next(iterator[, default])
```
Параметры  
* iterator: Итератор, из которого нужно получить следующий элемент.  
* default: (необязательный) Значение, которое будет возвращено, если итератор исчерпан. Если параметр default не указан, то при исчерпании итератора будет вызвано исключение StopIteration.  

`[iter()]` - функция, которая создаёт итератор на основе коллекции. 

#

`[Коллекция]` — объект, хранящий набор значений одного или различных типов, позволяющий обращаться к этим значениям, а также применять специальные функции и методы, зависящие от типа коллекции.

`[Последовательность]` - коллекция, элементы которой пронумерованы индексами и расположены в строгом порядке. 

Коллекции не являются итераторами сами по себе, но позволяют создать итератор на своей основе при помощи функции `iter()`

#

### Преимущества итераторов  
Основными преимуществами использования итераторов являются:  
* однотипность работы с объектами разных типов  
* ленивые вычисления и экономия потребляемой памяти  
* комбинация множества итераторов для создания понятной и читабельной программы  

<details>
  <summary>Однотипность работы с объектами разных типов</summary>

Итераторы предоставляют единый интерфейс для перебора элементов любых итерируемых объектов, таких как списки, кортежи, множества, словари и даже пользовательские коллекции.   

Независимо от типа итерируемого объекта, ты всегда можешь использовать одинаковые методы и функции (iter(), next(), и цикл for), чтобы последовательно получать его элементы.

```
# Список
numbers = [1, 2, 3]
numbers_iterator = iter(numbers)
print(next(numbers_iterator))  # Выведет 1

# Кортеж
letters = ('a', 'b', 'c')
letters_iterator = iter(letters)
print(next(letters_iterator))  # Выведет 'a'

# Словарь
dictionary = {'key1': 'value1', 'key2': 'value2'}
dictionary_iterator = iter(dictionary)
print(next(dictionary_iterator))  # Выведет 'key1' или 'key2'
```

#

</details>
<details>
  <summary>Ленивые вычисления и экономия потребляемой памяти</summary>

### Ленивые вычисления  
Ленивые вычисления означают, что значения вычисляются только тогда, когда они действительно необходимы, а не заранее. Это позволяет уменьшить потребление памяти и повысить производительность при работе с большими наборами данных.  

### Экономия памяти  
Когда ты работаешь с итераторами и генераторами, элементы последовательности создаются по одному за раз и не хранятся в памяти все сразу. Это особенно важно при работе с большими данными, так как позволяет избежать загрузки всей последовательности в память, экономя ресурсы.

#

</details>
<details>
  <summary>Комбинация множества итераторов
</summary>

Комбинирование множества итераторов позволяет создавать сложные последовательности данных, используя несколько простых итераторов.  

```
sentence = 'In the face of ambiguity refuse the temptation to guess'

filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем

for index, value in enumerate_iterator:                                  # выводим
    print(f'{index}. {value}')
```
Выводит:
```
1. AMBIGUITY
2. REFUSE
3. TEMPTATION
4. GUESS
```

#

</details>
<details>
  <summary>Функции возвращающие итераторы</summary>

1. `[iter()]` - Преобразует итерируемый объект в итератор.
```
numbers = [1, 2, 3]
iterator = iter(numbers)
print(next(iterator))  # Выведет 1
```

2. `[map()]` - Применяет функцию к каждому элементу итерируемого объекта и возвращает итератор с результатами.
```
def square(x):
    return x * 2

numbers = [1, 2, 3]
iterator = map(square, numbers)
print(next(iterator))  # Выведет 2
```

3. `[filter()]` - Возвращает итератор, состоящий из элементов итерируемого объекта, для которых функция возвращает True.
```
def is_even(x):
    return x % 2 == 0

numbers = [1, 2, 3, 4]
iterator = filter(is_even, numbers)
print(next(iterator))  # Выведет 2
```

4. `[enumerate()]` - Возвращает итератор, который генерирует кортежи, содержащие индекс и значение каждого элемента итерируемого объекта.
```
letters = ['a', 'b', 'c']
iterator = enumerate(letters)
print(next(iterator))  # Выведет (0, 'a')
```
5. `[zip()]` - Возвращает итератор, который генерирует кортежи, состоящие из элементов, взятых по одному из каждого итерируемого объекта.
```
numbers = [1, 2, 3]
letters = ['a', 'b', 'c']
iterator = zip(numbers, letters)
print(next(iterator))  # Выведет (1, 'a')
```
<details>
  <summary>Функции из модуля itertools</summary>

1. `[itertools.count()]` - Возвращает итератор, который генерирует бесконечную последовательность чисел, начиная с указанного значения.
```
import itertools

counter = itertools.count(start=10)
print(next(counter))  # Выведет 10
```
2. `[itertools.cycle()]` - Возвращает итератор, который бесконечно повторяет элементы итерируемого объекта.
```
import itertools

cycler = itertools.cycle([1, 2, 3])
print(next(cycler))  # Выведет 1
```
3. `[itertools.repeat()]` - Возвращает итератор, который бесконечно повторяет указанное значение (либо указанное количество раз).
```
import itertools

repeater = itertools.repeat('hello', 3)
print(next(repeater))  # Выведет 'hello'
```
4. `[itertools.chain()]` - Возвращает итератор, который последовательно перебирает элементы нескольких итерируемых объектов.
```
import itertools

chain = itertools.chain([1, 2, 3], ['a', 'b', 'c'])
print(next(chain))  # Выведет 1
```
5. `[itertools.islice()]` - Возвращает итератор, который генерирует элементы из итерируемого объекта, начиная с указанной позиции и до указанной позиции.
```
import itertools

sliced = itertools.islice(range(10), 2, 5)
print(next(sliced))  # Выведет 2
```
6. `[itertools.combinations()]` - Возвращает итератор, который генерирует все возможные комбинации указанной длины из элементов итерируемого объекта.
```
import itertools

comb = itertools.combinations([1, 2, 3], 2)
print(next(comb))  # Выведет (1, 2)
```
7. `[itertools.permutations()]` - Возвращает итератор, который генерирует все возможные перестановки из элементов итерируемого объекта указанной длины.
```
import itertools

perm = itertools.permutations([1, 2, 3], 2)
print(next(perm))  # Выведет (1, 2)
```




#

</details>


#

</details>















<details>
  <summary>Null</summary>



#

</details>
