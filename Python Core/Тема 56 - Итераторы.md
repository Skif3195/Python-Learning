# Итераторы

`[Итерируемый объект`] - объект, который можно итерировать, то есть проходиться по нему, перебирая каждый элемент раз за разом.  

Существует два типа итерируемых объектов:

1. Итераторы
2. Коллекции и последовательности


Итераторы

`[Итератор]` — специальный объект, который выдает свои элементы по одному за раз.  
`[next()]` - возвращает следующий элемент из последовательности. Когда элементы заканчиваются, метод должен вызывать исключение StopIteration.
```
next(iterator[, default])
```
Параметры  
* iterator: Итератор, из которого нужно получить следующий элемент.  
* default: (необязательный) Значение, которое будет возвращено, если итератор исчерпан. Если параметр default не указан, то при исчерпании итератора будет вызвано исключение StopIteration.  

`[iter()]` - функция, которая создаёт итератор на основе коллекции. 

#

`[Коллекция]` — объект, хранящий набор значений одного или различных типов, позволяющий обращаться к этим значениям, а также применять специальные функции и методы, зависящие от типа коллекции.

`[Последовательность]` - коллекция, элементы которой пронумерованы индексами и расположены в строгом порядке. 

Коллекции не являются итераторами сами по себе, но позволяют создать итератор на своей основе при помощи функции `iter()`

#

`[Итератор]` — специальный объект, который выдает свои элементы по одному за раз.  

### Преимущества итераторов  
Основными преимуществами использования итераторов являются:  
* однотипность работы с объектами разных типов  
* ленивые вычисления и экономия потребляемой памяти  
* комбинация множества итераторов для создания понятной и читабельной программы

Самое простое, что можно сделать с итератором, — это его последовательный обход с помощью цикла `for`. 

<details>
  <summary>Цикл for</summary>

При итерировании циклом `for` по словарю мы получаем только ключи.


Приведенный ниже код:
```
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num, end=' ')
```
выводит:
```
3 6 1 90 34 25 23 21 
```

Приведенный ниже код:
```
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)     # создаем объект итератора

for num in positive_numbers:             # обходим итератор циклом for
    print(num, end=' ')

for num in positive_numbers:             # обходим пустой итератор, тело цикла выполнено не будет
    print(num, end=' ')
```
выводит все тот же результат:
```
3 6 1 90 34 25 23 21 
```
Поскольку после первого цикла `for` итератор `positive_numbers` становится пустым и его повторный обход ни к чему не приведет.   
Цикл `for` сам перехватывает исключение `StopIteration`

#

</details>
<details>
  <summary>Преобразование в коллекцию</summary>

Что бы преобразовать итератор в коллекцию можно использовать встроенноые функции (list(), tuple(), …)

Один раз применив встроенную функцию к итератору, он опустошается а его содержимое становится содержимым коллекции. 

```
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]

positive_numbers = map(abs, numbers)                  # создаем объект итератора

positive_numbers_list1 = list(positive_numbers)       # преобразуем итератор в список
positive_numbers_list2 = list(positive_numbers)       # преобразуем пустой итератор в список

print(positive_numbers_list1)
print(positive_numbers_list2)
```
Выведет 
```
[3, 6, 1, 90, 34, 25, 23, 21]
[]
```

#

</details>
<details>
  <summary>Оператор принадлежности in</summary>

Оператор принадлежности `in` работает и с итераторами.   
Проверка на вхождение осуществляется путем перебора всех элементов последовательно, и как только элемент обнаружен, поиск прекращается  
```
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator).  # True
```
Однако тут нужно понимать, что по мере поиска итератор опустошается, поскольку оператор `in` за кулисами вызывает функцию `next()` для получения следующего элемента. 
```
 numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator).  # True
print(15 in iterator).  # False
```
При этом после второй проверки на принадлежность итератор `iterato`r полностью опустошается и последующие поиски по нему всегда будут приводить к результату `False`.
```
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(15 in iterator).  # True
print(23 in iterator)   # True
```

#

</details>
<details>
  <summary>Распаковка итератора</summary>

Мы также можем распаковывать содержимое итератора, автоматически опустошая его.  

```
numbers = [4, 8, 15, 16, 23, 42]

iterator = iter(numbers)              # создаем итератор на основе списка

print(*iterator)   # 4 8 15 16 23 42
print(list(iterator)).  # []
```
- При распаковке словаря, мы получаем только ключи.

#

</details>

<details>
  <summary>Однотипность работы с объектами разных типов</summary>

Итераторы предоставляют единый интерфейс для перебора элементов любых итерируемых объектов, таких как списки, кортежи, множества, словари и даже пользовательские коллекции.   

Независимо от типа итерируемого объекта, ты всегда можешь использовать одинаковые методы и функции (iter(), next(), и цикл for), чтобы последовательно получать его элементы.

```
# Список
numbers = [1, 2, 3]
numbers_iterator = iter(numbers)
print(next(numbers_iterator))  # Выведет 1

# Кортеж
letters = ('a', 'b', 'c')
letters_iterator = iter(letters)
print(next(letters_iterator))  # Выведет 'a'

# Словарь
dictionary = {'key1': 'value1', 'key2': 'value2'}
dictionary_iterator = iter(dictionary)
print(next(dictionary_iterator))  # Выведет 'key1' или 'key2'
```

#

</details>
<details>
  <summary>Ленивые вычисления и экономия потребляемой памяти</summary>

### Ленивые вычисления  
Ленивые вычисления означают, что значения вычисляются только тогда, когда они действительно необходимы, а не заранее. Это позволяет уменьшить потребление памяти и повысить производительность при работе с большими наборами данных.  

### Экономия памяти  
Когда ты работаешь с итераторами и генераторами, элементы последовательности создаются по одному за раз и не хранятся в памяти все сразу. Это особенно важно при работе с большими данными, так как позволяет избежать загрузки всей последовательности в память, экономя ресурсы.

#

</details>
<details>
  <summary>Комбинация множества итераторов
</summary>

Комбинирование множества итераторов позволяет создавать сложные последовательности данных, используя несколько простых итераторов.  

```
sentence = 'In the face of ambiguity refuse the temptation to guess'

filter_iterator = filter(lambda word: len(word) > 4, sentence.split())   # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator)           # преобразовываем
enumerate_iterator = enumerate(map_iterator, 1)                          # нумеруем

for index, value in enumerate_iterator:                                  # выводим
    print(f'{index}. {value}')
```
Выводит:
```
1. AMBIGUITY
2. REFUSE
3. TEMPTATION
4. GUESS
```

#

</details>
<details>
  <summary>Функции возвращающие итераторы</summary>

1. `[iter()]` - Преобразует итерируемый объект в итератор.
```
numbers = [1, 2, 3]
iterator = iter(numbers)
print(next(iterator))  # Выведет 1
```

2. `[map()]` - Применяет функцию к каждому элементу итерируемого объекта и возвращает итератор с результатами.
```
def square(x):
    return x * 2

numbers = [1, 2, 3]
iterator = map(square, numbers)
print(next(iterator))  # Выведет 2
```

3. `[filter()]` - Возвращает итератор, состоящий из элементов итерируемого объекта, для которых функция возвращает True.
```
def is_even(x):
    return x % 2 == 0

numbers = [1, 2, 3, 4]
iterator = filter(is_even, numbers)
print(next(iterator))  # Выведет 2
```

4. `[enumerate()]` - Возвращает итератор, который генерирует кортежи, содержащие индекс и значение каждого элемента итерируемого объекта.
```
letters = ['a', 'b', 'c']
iterator = enumerate(letters)
print(next(iterator))  # Выведет (0, 'a')
```
5. `[zip()]` - Возвращает итератор, который генерирует кортежи, состоящие из элементов, взятых по одному из каждого итерируемого объекта.
```
numbers = [1, 2, 3]
letters = ['a', 'b', 'c']
iterator = zip(numbers, letters)
print(next(iterator))  # Выведет (1, 'a')
```
<details>
  <summary>Функции из модуля itertools</summary>

1. `[itertools.count()]` - Возвращает итератор, который генерирует бесконечную последовательность чисел, начиная с указанного значения.
```
import itertools

counter = itertools.count(start=10)
print(next(counter))  # Выведет 10
```
2. `[itertools.cycle()]` - Возвращает итератор, который бесконечно повторяет элементы итерируемого объекта.
```
import itertools

cycler = itertools.cycle([1, 2, 3])
print(next(cycler))  # Выведет 1
```
3. `[itertools.repeat()]` - Возвращает итератор, который бесконечно повторяет указанное значение (либо указанное количество раз).
```
import itertools

repeater = itertools.repeat('hello', 3)
print(next(repeater))  # Выведет 'hello'
```
4. `[itertools.chain()]` - Возвращает итератор, который последовательно перебирает элементы нескольких итерируемых объектов.
```
import itertools

chain = itertools.chain([1, 2, 3], ['a', 'b', 'c'])
print(next(chain))  # Выведет 1
```
5. `[itertools.islice()]` - Возвращает итератор, который генерирует элементы из итерируемого объекта, начиная с указанной позиции и до указанной позиции.
```
import itertools

sliced = itertools.islice(range(10), 2, 5)
print(next(sliced))  # Выведет 2
```
6. `[itertools.combinations()]` - Возвращает итератор, который генерирует все возможные комбинации указанной длины из элементов итерируемого объекта.
```
import itertools

comb = itertools.combinations([1, 2, 3], 2)
print(next(comb))  # Выведет (1, 2)
```
7. `[itertools.permutations()]` - Возвращает итератор, который генерирует все возможные перестановки из элементов итерируемого объекта указанной длины.
```
import itertools

perm = itertools.permutations([1, 2, 3], 2)
print(next(perm))  # Выведет (1, 2)
```




#

</details>


#

</details>
<details>
  <summary>Функция map()</summary>

Функция `map(function, *iterable)` применяет пользовательскую функцию `function` к каждому элементу итерируемого объекта `iterable`.    
Каждый элемент `iterable` отправляется в функцию `function` в качестве аргумента.  

### Возвращаемое значение: 
Функция `map()` возвращает итератор типа `<class 'map'>`.   

### Примечание: 
Если в функцию `map()` передаётся несколько итерируемых объектов `iterable`, то пользовательская функция `function` должна принимать количество аргументов, соответствующее количеству переданных итерируемых объектов, при этом `function` будет применяться к элементам из всех итераций параллельно.    

### Преимущества использования:
Функция `map()` написана на языке `C` и хорошо оптимизирована, ее внутренний цикл более эффективный, чем обычный цикл `for` в `Python`.   

Функция `map()` потребляет мало памяти, так как возвращает ленивый итератор элементы которого извлекаются по запросу.  

### Примеры использования  
Приведенный ниже код:
```
from sys import getsizeof

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
letters = 'beegeek'

squares = map(lambda num: num ** 2, numbers)
capitals = map(str.upper, letters)

print(f'Тип итератора squares: {type(squares)}, размер: {getsizeof(squares)}')
print(f'Тип итератора capitals: {type(capitals)}, размер: {getsizeof(capitals)}')

print(*squares, sep=' ')
print(*capitals, sep=' ')
```
Выведет:
```
Тип итератора squares: <class 'map'>, размер: 48
Тип итератора capitals: <class 'map'>, размер: 48
1 4 9 16 25 36 49 64 81 100
B E E G E E K
```
размер итератора типа `<class 'map'>` всегда равен `48 байтам`, независимо от размера итерируемого объекта.
#

</details>
<details>
  <summary>Функция filter()</summary>

Функция `filter(function, iterable)` фильтрует (отбирает) элементы переданного итерируемого объекта `iterable` при помощи пользовательской функции `function`.   

Если фильтрующая функция `function` вернёт `True`, то элемент из итерируемого объекта `iterable` попадёт в результат выполнения функции `filter()`, если `False` — не попадёт.  

### Возвращаемое значение:   
Функция `filter()` возвращает итератор типа `<class 'filter'>`.  

### Примечание:   
Если `function=None`, то в результат выполнения функции `filter()` попадут те элементы, которые при переводе в логический тип имеют значение `True`.  

### Преимущества использования:   
Функция `filter()` написана на языке `C` и хорошо оптимизирована, ее внутренний цикл более эффективный, чем обычный цикл `for` в `Python`. Функция `filter()` потребляет мало памяти, так как возвращает итератор, элементы которого извлекаются по запросу.  

### Примеры использования:
Приведенный ниже код:
```
from sys import getsizeof

numbers = [45, -90, -21, 4, 89, 43, 1234, 112, 999, 777, -765, -666]
objects = ('a', None, 45, True, 69.69, False, -1, 0, 'empty', '')

positive_numbers = filter(lambda num: num > 0, numbers)
not_nulls = filter(None, objects)

print(f'Тип итератора positive_numbers: {type(positive_numbers)}, размер: {getsizeof(positive_numbers)}')
print(f'Тип итератора not_nulls: {type(not_nulls)}, размер: {getsizeof(not_nulls)}')

print(*positive_numbers, sep=' ')
print(*not_nulls, sep=' ')
```
Выведет:
```
Тип итератора positive_numbers: <class 'filter'>, размер: 48
Тип итератора not_nulls: <class 'filter'>, размер: 48
45 4 89 43 1234 112 999 777
a 45 True 69.69 -1 empty
```
Pазмер итератора типа <class 'filter'> всегда равен 48 байтам, независимо от размера итерируемого объекта.

#

</details>

<details>
  <summary> Функция enumerate()</summary>

Функция `enumerate(iterable, start=0`) нумерует элементы итерируемого объекта `iterable`, начиная со значения start.  

Возвращаемое значение:   
Функция `enumerate()` возвращает итератор типа `<class 'enumerate'>`, содержащий кортежи вида `(счётчик, элемент)`.  

Примечание:  
По умолчанию нумерация начинается с нуля.  

Преимущества использования:  
Функция `enumerate()` потребляет мало памяти, так как возвращает итератор, элементы которого извлекаются по запросу.  

Примеры использования:
Приведенный ниже код
```
from sys import getsizeof

seasons = ['Spring', 'Summer', 'Fall', 'Winter']
letters = 'beegeek'

numbered_seasons = enumerate(seasons)
numbered_letters = enumerate(letters, start=1)

print(f'Тип итератора numbered_seasons: {type(numbered_seasons)}, размер: {getsizeof(numbered_seasons)}')
print(f'Тип итератора numbered_letters: {type(numbered_letters)}, размер: {getsizeof(numbered_letters)}')

print(*numbered_seasons, sep=' ')
print(*numbered_letters, sep=' ')
```
Выведет:
```
Тип итератора numbered_seasons: <class 'enumerate'>, размер: 64
Тип итератора numbered_letters: <class 'enumerate'>, размер: 64
(0, 'Spring') (1, 'Summer') (2, 'Fall') (3, 'Winter')
(1, 'b') (2, 'e') (3, 'e') (4, 'g') (5, 'e') (6, 'e') (7, 'k')
```
Размер итератора типа `<class 'enumerate'>`, он всегда равен `64 байтам`, независимо от размера итерируемого объекта.

#

</details>
<details>
  <summary>Функция zip()</summary>

Функция zip(*iterables, strict=False) объединяет элементы каждого из переданных итерируемых объектов *iterables.  

### Возвращаемое значение: 
Функция `zip()` возвращает итератор типа `<class 'zip'>`, содержащий кортежи, где `i-й кортеж` содержит `i-й элемент` из каждого итерируемого объекта.  

### Примечание:   
По умолчанию значение аргумента `strict=False`, то есть функция `zip()` останавливается, когда исчерпывается самый короткий итерируемый объект.  

Если установить значение `strict=True`, то функция `zip()` проверяет длины итерируемых объектов, вызывая ошибку `ValueError`, если они не совпадают.   

С одним итерируемым аргументом функция `zip()` возвращает итератор из кортежей с одним элементом, без аргументов функция возвращает пустой итератор.   

Параметр `strict` был добавлен в `Python 3.10`.  

### Преимущества использования: 
Функция `zip()` потребляет мало памяти, так как возвращает итератор, элементы которого извлекаются по запросу.  

### Примеры использования:   
Приведенный ниже код:
```
from sys import getsizeof

languages = ['Python', 'C#', 'C', 'Delphi'] 
years = [1991, 2000, 1972, 1986]
authors = ('Guido van Rossum', 'Anders Hejlsberg', 'Dennis MacAlistair Ritchie', 'Anders Hejlsberg')

zip_iterator1 = zip(languages, years)
zip_iterator2 = zip(languages, years, authors)

print(f'Тип итератора zip_iterator1: {type(zip_iterator1)}, размер: {getsizeof(zip_iterator1)}')
print(f'Тип итератора zip_iterator2: {type(zip_iterator2)}, размер: {getsizeof(zip_iterator2)}')

print(*zip_iterator1, sep=' ')
print(*zip_iterator2, sep=' ')
```
Выведет:
```
Тип итератора zip_iterator1: <class 'zip'>, размер: 64
Тип итератора zip_iterator2: <class 'zip'>, размер: 64
('Python', 1991) ('C#', 2000) ('C', 1972) ('Delphi', 1986)
('Python', 1991, 'Guido van Rossum') ('C#', 2000, 'Anders Hejlsberg') ('C', 1972, 'Dennis MacAlistair Ritchie') ('Delphi', 1986, 'Anders Hejlsberg')
```

#

</details>
<details>
  <summary>Функция reversed()</summary>

Функция `reversed(seq)` перебирает элементы итерируемого объекта `seq` в обратном порядке.  

### Возвращаемое значение:   
Функция `reversed()` возвращает итератор, содержащий элементы итерируемого объекта в обратном порядке.  

Примечание 1:   
Итерируемый объект, передаваемый в функцию `reversed()`, должен являться `последовательностью.  

Примечание 2:  
Функция `reversed()` не создает копию и не изменяет оригинал исходного итерируемого объекта.  

Преимущества использования:  
Функция `reversed()` потребляет мало памяти, так как возвращает ленивый итератор элементы которого извлекаются по запросу.  

Примеры использования:   
Приведенный ниже код
```
from sys import getsizeof

years = [1991, 2000, 1972, 1986]
letters = 'beegeek'

backward_years = reversed(years)
backward_letters = reversed(letters)

print(f'Тип итератора backward_years: {type(backward_years)}, размер: {getsizeof(backward_years)}')
print(f'Тип итератора backward_letters: {type(backward_letters)}, размер: {getsizeof(backward_letters)}')

print(*backward_years, sep=' ')
print(*backward_letters, sep=' ')
```
Выведет: 
```
Тип итератора backward_years: <class 'list_reverseiterator'>, размер: 48
Тип итератора backward_letters: <class 'reversed'>, размер: 48
1986 1972 2000 1991
k e e g e e b
```
- Размер итератора, он всегда равен 48 байтам, независимо от размера итерируемого объекта.

#

</details>














<details>
  <summary>Null</summary>



#

</details>
