# Множества - Тип `set()`

- `[Множества (тип set)]` -  это изменяемая, неупорядоченная коллекция уникальных элементов. То есть, каждый элемент в множестве уникален, и порядок их расположения не имеет значения.
  - Элементами мноесва могут быть любые неизменяемые типы данных (int / str / tuple).
  - Элементы множества уникальны и не могут повторяться.
  #
- `[Создание множества]` - Создать множество можно несколькими способами:
  - Внося последовательность в фигурные скобки  `{ }`
  - При помощи функции `[set()]`, без аргументов, создать пустое можество
  - При помощи функции `[set()]`, используя в качестве аргумента любую итерируемую последовательность
```
set_1 = {1, 2, 3}            # {1, 2, 3}
set_2 = set()                # Пустое множество: set()

my_list = [1, 2, 3]                  
set_3 = set(my_list)        # {1, 2, 3}
```
- При создании множества из итерируемых объектов порядок элементов может быть произвольным.
#
### Множества поддерживают:
- Функции `[len()]`, `[sum()]`, `[max()]`, `[min()]`
- Операторы `[in(not)]`, `[==]` и `[!=]`
- Оператор распаковки `[*]`

### Множества НЕ поддерживают:
- `[индексацию]`, `[срезы]`, `[конкатенацию]`, `[умножение на число]`
#

# Замороженные ножества - Тип `frozenset()

- `Замороженные множества]` -  это неизменяемые (immutable) версии множеств.

### Основные особенности:
  - Создаются как и обычные множества, но при помощи функции  `[frozenset()]`
  - `[Неизменяемость]` - Нельзя добавлять, удалять или изменять элементы в замороженном множестве после его создания
  - `[Хешируемость]` - Замороженные множества являются хешируемыми, что позволяет использовать их в качестве ключей словарей или элементов других множеств.
  - `[Поддержка операций множества]` - поддерживают основные операции множества, такие как `[проверка на вхождение]`, `[операции пересечения]` и `[объединения]`, но не поддерживают методы, которые изменяют множество.
#
# Методы Множеств
<details>
  <summary>Изменяющие множество</summary>

Данные методы изменяют уже существующее множество, не возвращая новое.
  
  ### 1) `[set.add()]` - используется для добавления элемента в множество. Если элемент уже присутствует, то множество остается неизменным.  
```
# Создаем множество
my_set = {1, 2, 3}

# Добавляем элемент
my_set.add(4)

# Выводим результат
print(my_set)  # {1, 2, 3, 4}

```
#
   ### 2) `[set.remove()]` - используется для удаления указанного элемента из множества. Если элемент не найден, он генерирует исключение KeyError.
```
# Создаем множество
my_set = {1, 2, 3, 4}

# Удаляем элемент
my_set.remove(3)

# Выводим результат
print(my_set)  # {1, 2, 4}
```
#
   ### 3) `[set.discard()]` -  подобен методу remove(), но не генерирует исключение, если указанный элемент не найден. Вместо этого он просто ничего не делает.
```
# Создаем множество
my_set = {1, 2, 3, 4}

# Удаляем элемент
my_set.discard(3)

# Выводим результат
print(my_set)  # {1, 2, 4}

# Попытка удаления отсутствующего элемента
my_set.discard(5)

# Выводим результат снова
print(my_set)  # {1, 2, 4}
```
#
   ### 4) `[set.pop()]` - используется для удаления и возврата произвольного элемента из множества. Так как множества не упорядочены, нельзя точно предсказать, какой элемент будет удален.
```
# Создаем множество
my_set = {1, 2, 3, 4, 5}

# Удаляем и возвращаем произвольный элемент
removed_element = my_set.pop()

# Выводим результат
print(f"Удаленный элемент: {removed_element}")      # Случайный элемент множества
print(f"Оставшиеся элементы: {my_set}")

```
#
  ### 5) `[set.clear()]` - используется для удаления всех элементов из множества, делая его пустым.
```
# Создаем множество
my_set = {1, 2, 3, 4}

# Очищаем множество
my_set.clear()

# Выводим результат
print(my_set)  # set()

```
</details>

<details>
  <summary>Создающие новое множество</summary>

Данные методы собирают новое множество на основе двух и более других методов, исходя из условий метода.
  
   ### 1) `[set.union()]` - (Оператор `[|]`) используется для создания нового множества, содержащего все уникальные элементы из двух или более итерируемых объектов:
```
# Создаем три множества
set1 = {1, 2, 3}
set2 = {3, 4, 5}
list1 = [5, 6, 7]

# Объединяем все три множества
union_set = set1.union(set2, list1)
# С использованием оператора
union_set = set1 | set2 | list1

# Выводим результат
print(union_set)  # {1, 2, 3, 4, 5, 6, 7}
```
Метод union() может принимать любое количество множеств в качестве аргументов и объединять их в новое множество, содержащее уникальные элементы. 
#
   ### 2) `[set.intersection()]` - (Оператор `[&]`) используется для получения пересечения двух или более множеств, возвращая новое множество, содержащее только те элементы, которые присутствуют во всех исходных итерируемых объектах:
```
# Создаем три множества
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
list1 = [4, 5, 6, 7]

# Получаем пересечение всех трех итер объектов
intersection_set = set1.intersection(set2, list1)

# Получаем пересечение всех трех множеств с использованием оператора &
intersection_set = set1 & set2 & list1

# Выводим результат
print(intersection_set)  # {4}

```
#
   ### 3) `[set.difference()]` - (Оператор `[-]`) используются для получения разности двух и более множеств или других итерируемых объектов. Разность множеств включает в себя все элементы из первого множества, которые отсутствуют во втором множестве.
```
# Создаем три множества
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
list1 = [4, 5, 6, 7]

# Получаем разность с использованием метода difference()
difference_set_method = set1.difference(set2, list1)

# Получаем разность с использованием оператора '-'
difference_set_operator = set1 - set2 - list1

# Выводим результат
print(difference_set_method)  # {1, 2}
print(difference_set_operator)  # {1, 2}

```
#
   ### 4) `[set.symmetric_difference()]` - (Оператор `[^]`) используются для получения симметрической разности двух и более множеств или других итерируемых объектов. Симметрическая разность включает в себя элементы, присутствующие только в одном из множеств, но не в обоих.
```
# Создаем три множества
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
list1 = [4, 5, 6, 7]

# Получаем симметрическую разность с использованием метода symmetric_difference()
symmetric_difference_set_method = set1.symmetric_difference(set2, list1)

# Получаем симметрическую разность с использованием оператора ^
symmetric_difference_set_operator = set1 ^ set2 ^ list1

# Выводим результат
print(symmetric_difference_set_method)  # {1, 2, 7}
print(symmetric_difference_set_operator)  # {1, 2, 7}
```
</details>

<details>
  <summary>Обновление множества</summary>

### Данные методы обнавляют уже существующее множество элементами других множеств или итерируемых обЪектов.
### Изменяют исходное множество а не возвращают новое.
### Операторы данных методов работают только с множествами
  
  ### 1) `[set.update()]` - (Оператор `[|=]`) используется для обновления множества, добавляя элементы из другого итерируемого объекта, такого как список или другое множество.
```
# Создаем два итерируемых объекта
set1 = {1, 2, 3}
set2 = {3, 4, 5}
list1 = [6, 7, 8]

# Обновляем set1, добавляя элементы из set2 и list1
set1.update(set2, list1)
# Использование оператора
set1 |= set2 | set(list1)

# Выводим результат
print(set1)  # {1, 2, 3, 4, 5, 6, 7, 8}

```
#
   ### 2) `[set.intersection_update()]` - (Оператор `[&=]`) используется для обновления множества, оставляя в нем только элементы, которые присутствуют во всех указанных множествах или итерируемых объектах.
```
# Создаем два множества и один список
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
list1 = [4, 5, 6, 7]

# Обновляем set1, оставляя только элементы, присутствующие в set2 и list1
set1.intersection_update(set2, list1)

# Используем оператор &= для обновления set1
set1 &= set2 & set(list1)

# Выводим результат
print(set1)  # {4, 5}

```
#
   ### 3) `[set.difference_update()]` - (Оператор `[-=]`)  используется для обновления множества, удаляя из него элементы, которые присутствуют в других указанных множествах или итерируемых объектах.
```
# Создаем два множества и один список
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
list1 = [4, 5, 6, 7]

# Обновляем set1, удаляя элементы, присутствующие в set2 и list1
set1.difference_update(set2, list1)

# Используем оператор -= для обновления set1
# Oбъединяем множества set2 и list1 с помощью оператора |, чтобы получить все элементы, присутствующие в обоих множествах.
set1 -= set(set2) | set(list1)

# Выводим результат
print(set1)  # {1, 2}

```
#
   ### 4) `[set.symmetric_difference_update()]` - (Оператор `[^=]`) используется для обновления множества, оставляя в нем только элементы, которые присутствуют только в одном из указанных множеств или итерируемых объектов.
```
# Создаем два множества и один список
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
list1 = [4, 5, 6, 7]

# Обновляем set1, оставляя только элементы, присутствующие только в одном из set2 и list1
set1.symmetric_difference_update(set2, list1)

# Используем оператор ^= для обновления set1
set1 ^= set(set2) ^ set(list1)

# Выводим результат
print(set1)  # {1, 2, 7}
```
</details>

<details>
  <summary>Логические методы</summary>
  
   - `[set.]` -
```

```
#
   - `[set.]` -
```

```
#
   - `[set.]` -
```

```
</details>
