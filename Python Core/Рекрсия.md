# Рекурсия

`[Рекурсивная функция]` - это функция, которая вызывает саму себя.

   - Подобно циклу, рекурсивная функция должна иметь определенный способ управлять количеством своих повторов.
   - То есть, условие окончания работы функции. 

#

Основные понятия:

1. `Рекурсивная функция` - функция которая выполняет сама себя;
2. `Рекурсивный вызов` - вызов функции самой себя;
3. `Стек` - это абстрактная структура данных, которая представляет собой упорядоченную коллекцию элементов, в которой добавление и удаление элементов происходит только с одного конца, называемого вершиной стека. Элементы стека добавляются и извлекаются в порядке "последним пришел - первым вышел" (Last-In-First-Out, LIFO);
4. `Базовый случай` - момент работы рекурсивной функции, когда рекурсия доходит до минимального значения а стек полностью заполняется;
5. `Рекурсивный случай` - часть рекурсивной функции, определяющий условие работы рекурсии (Оно же условие возникновения базового случая). Это условие определяет должна ли функция вызывать сама себя и достигнут ли базовый случай;  
5. `Глубина рекурсии` - количество раз, которое функция вызывает сама себя, опуская вызов из основной программы;
6. `Хвостовая рекурсия` - вариант, в котором рекурсивный вызов является последней операцией функции;
7. `Обычная рекурсия` - не имеет ограничен на место рекурсивного вызова в функции;

#

### Для понимания приведём два примера:

<details>
  <summary>Пример 1</summary>

*Хвостовая рекурсия*

Приведённый ниже код:

```
def message(times):
    if times > 0:
        print(‘times)
        message(times - 1)

message(5)
```

Выведет:

```
5
4
3
2
1
```

1. Функция message принимает значение 5;
2. Определяется рекурсивный случай, условие работы рекурсивной функции (условие, до которого функция будет вызывать сама себя). Это же условие является условием базового случая. В данном случае, пока переданное значение больше нуля;
3. Происходит печать текста;
4. Далее функция вызывает сама себя со значением уменьшенным на 1;
5. И так до возникновения базового случая (n = 0);
6. С начала работы функции и до достижения базового случают происходит заполнения стека значениями от 5 до 0. На 0 значении происходит базовый случай. Функция перестаёт вызывать сама себя. Прекращается печать текста;
7. Под капотом начинается обратная рекурсия по стеку, с каждой итерацией возвращаясь у исходному значению (от 0 до 5); 
8. При достижении начального значения стек опустошается и перестаёт существовать;
9. Функция полностью прекращает свою работу;
</details>
<details>
  <summary>Пример 2</summary>

*Обыкновенная рекурсия*

Приведённый ниже код:

```
def bee(n):
    if n > 0:
        bee(n - 1)
        print(n)

bee(3)
```

Выведет:

```
1
2
3
```

1. Функция `bee` принимает значение 3;
2. Определяется рекурсивный случай, условие работы рекурсивной функции (условие, до которого функция будет вызывать сама себя). Это же условие является условием базового случая. В данном случае, пока переданное значение больше нуля;
3. Далее функция вызывает сама себя со значением уменьшенным на 1. И так до достижения условия базового случая (n = 0);
4. На этом моменте стек наполнен значениями 3-2-1-0. На значении 0 происходит базовый случай и работа функции передаётся предыдущей итерации;
5. На этом моменте работа программы переходит к команде print(n). n данном случае равно 1, так как под капотом мы находимся на вершине стека, на последнем добавленном в него значении, которое равно 1;
6. На этом моменте визуальная часть работы функции (печать значения n) происходит до тех пор, пока значения в стеке не достигнут стартового. 
7. При достижении старого значения, стек становится пустым, печать значений прекращается, функция полностью прекращает свою работу;

#
</details>
<details>
  <summary>Хвостовая рекурсия</summary>

`Хвостовая рекурсия` - это специальный случай рекурсивной функции, при котором  рекурсивный вызов происходит после любых рекурсивных изменений переданных аргументов?
Другими словами, рекурсивный вызов происходит только тогда, когда произведены все операции в функции и итоговое значение помещено в стек.  

Про этом в хвостовой рекурсии, после рекурсивного вызова может происходить операция обратной рекурсии - например вывод элементов стека в обратном порядке.

Данный пример:
```
def print_hourglass(n):
    if n <= 0:
        return
    digits = str(n) * (2 * n)
    print(digits.center(16))
    print_hourglass(n - 1)
    print(digits.center(16))

print_hourglass(5)
```
Выведет:
```
   5555555555   
    44444444    
     333333     
      2222      
       11       
       11       
      2222      
     333333     
    44444444    
   5555555555 
```
#
</details>

#

<details>
  <summary>Дополнительные примечания</summary>
   
...
1. Любая задача, которая может быть решена рекурсивно, также может быть решена на основе цикла, и наоборот.
2. Рекурсивные алгоритмы обычно менее эффективны, чем итеративные алгоритмы.
3. В целом рекурсивная функция работает следующим образом:

      - если в настоящий момент задача может быть решена без рекурсии, то функция ее решает
      - если в настоящий момент задача не может быть решена, то функция ее сводит к уменьшенной и при этом аналогичной задаче и вызывает саму себя для решения этой уменьшенной задачи


</details>
<details>
  <summary>Замыкание</summary>

`Замыкание` - это свойство вложенной функции, которая сохраняет доступ к переменным из области видимости родительской функции, в которой она была определена, даже после завершения выполнения родительской функции или после удаления её из памяти.  

Замыкание обеспечивает сохранение контекста выполнения и доступ к переменным из внешней области видимости, что позволяет использовать их внутри вложенной функции в дальнейшем.

<details>
  <summary>Пример №1</summary>

```
def up_func():
    x = 10
    def dawn_func():
        print(x)
    return dawn_func

my_func = up_func()
del up_func  # Удаляем родительскую функцию

# Вызываем вложенную функцию, которая продолжает работать
my_func()  # Выведет: 10
```
1. Создается родительская функция up_func(), внутри которой определяется переменная x со значением 10, и вложенная функция замыкания dawn_func.

3.  Функция dawn_func() имеет доступ к переменной x, так как она находится в области видимости родительской функции.
4.  Затем мы присваиваем переменной my_func результат вызова up_func(). Это означает, что my_func теперь ссылается на вложенную функцию dawn_func, и она сохраняет доступ к переменной x, даже после того как up_func() была удалена.
5.  После этого мы удаляем родительскую функцию с помощью оператора del up_func. Это не влияет на доступность и работу вложенной функции.
6.  Наконец, вызываем my_func(), что приводит к выводу значения переменной x, которая была определена в родительской функции до её удаления. Таким образом, выводится число 10.

*Это связано с особенностью функции замыкания. Она сохраняет доступ к переменным объявленным в родительской функции и их состояние даже при удалении родительской функции. 
То есть ссылаясь на родительскую функции мы сослались не на саму функцию, а на ее содержимое (функцию замыкания и переменные, с которыми эта функция связана).*

#
</details>
<details>
  <summary>Пример №2</summary>

```
numbers = [243, -279, 395, 130, 89, 269, 861, 669, 939, 367, -46, 710, 841, -280, -244, 274, -132, 273, 418, 432, -341,
           437, 360, 960, 195, 792, 106, 461, -35, 980, -80, 540, -358, 69, -26, -416, 597, 96, 533, 232, 755, 894, 331,
           323, -383, -386, 231, 436, 553, 967, 166, -151, 772, 434, 325, 301, 275, 431, 556, 728, 558, 702, 463, 127,
           984, 212, 876, -287, -16, -177, 577, 604, 116, 500, 653, 669, 916, 802, 817, 762, -210, -353, 144, -351, 777,
           805, 692, 22, -303, 249, 190, 411, 236, -274, 174, 380, 71, 124, -85, 430]

def num_bers(iter):
    x = -1

    def count(x):
        if x < len(iter):
            print(f'Элемент {x}: {iter[x]}')
            count(x + 1)  # Рекурсивный вызов с увеличением аргумента

    count(x + 1)

num_bers(numbers)
```

1. Создается список numbers, содержащий числовые значения.  
2. Определяется внешняя функция num_bers(iter), принимающая список в качестве аргумента.
3. Внутри num_bers(iter) инициализируется переменная x со значением -1.
4. Определяется вложенная функция count(x), которая будет использоваться для рекурсивного перебора элементов списка.
5. В функции count(x) проверяется условие: если x меньше длины списка iter, то:

      - Выводится элемент списка iter с индексом x.
      - Происходит рекурсивный вызов count(x + 1), чтобы перейти к следующему элементу списка.
6. Первоначальный вызов count(x + 1) из функции num_bers(iter) начинает рекурсивный процесс, перебирающий все элементы списка.

#
</details>



</details>











#

<details>
  <summary></summary>



</details>


