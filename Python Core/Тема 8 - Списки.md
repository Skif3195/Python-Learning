# Списки - Тип list `[ ]`

- `[Список (тип list)]` - изменяемый тип коллекции в Python. Списком является последовательность символов, заключенных в квадратные скобки, перечисленные через запятую.  
#
- `[Обратная индексация]` - Последний элемент строки имеет индекс -1, предпоследний -2 и тд.

```
              0  1  2  3  4  5
  my_list =  [P, y, t, h, o, n]
             -6 -5 -4 -3 -2 -1
```
#
- `[Создание списка]` - Создать список можно при помощи функции `[list()]` либо при помощи квадрат ных скобок `[ ]`
```
list_1 = list()            # Пустой список: []
list_2 = list(1, 2, 3)     # [1, 2, 3]
list_3 = []                # Пустой список: []
list_3 = [1, 2, 3]         # [1, 2, 3]
```
#
- `[list()]` - преобразовывает в список любую другую итерируемую коллекцию.
#
- `[len()]` - Функция для определения длины (количества элементов) коллекции.
```
my_list = [1, 2, 3, 4, 5]
print(len(my_list))        # 5
```
#
- `[sum(iterable, start)]` - Функция для вычисления суммы элементов коллекции. 
```
my_list = [1, 2, 3, 4, 5]
print(sum(my_list))        # 15
```
#
- `[max()]` - Функция для нахождения наибольшего элемента коллекции.
```
my_list = [1, 2, 3, 4, 5]
print(max(my_list))        # 5
```
#
- `[min()]` - Функция для нахождения наименьшего элемента коллекции.
```
my_list = [1, 2, 3, 4, 5]
print(min(my_list))        # 1
```
#
- `[in]` - оператор проверки вхождения элемента в список (или любую другую коллекцию).
```
my_list = [1, 2, 3, 4, 5]
print(1 in my_list)            # True
```
#
- `[Конкатенация]` - сложение списков используя оператор `[+]`
#
- `[Стрезы]` - Срез (или slicing) - извлечение части списка. Это достигается путём указания индекса первого и последнего элементов, а так же шага среза.

Срез указывается после имени переменной в квадратных скобках, через двоеточие:  
 `[ my_list = ['P', 'y', 't', 'h', 'o', 'n'] ]`
 `[ my_list[1:6:2] ]` -> ['y', 'h', 'n ]  
 `[ my_list[0 : ] ]` - срез от первого элемента и до конца списка.  
 `[ my_list[ : n] ]` - срез от начала списка и до элемента под индексом `[n]`  
 `[ my_list[ : :-1] ]` - отрицательный шаг среза. Выведет список в обратном порядке.  
 #
- `[ * ]` - оператор умножения коллекции на число. Создает новую коллекцию, в которой элементы повторяются заданное количество раз.
```
my_list = [1, 2, 3]
print(my_list * 3)            # [1, 2, 3, 1, 2, 3, 1, 2, 3]
```
#
- `[+=]` и `[*=]` - Списки поддерживают расширенные операторы присвоение. Они помогают сделать код более ёмким.
```
my_list = [1, 2, 3]
my_list += [4, 5, 6]
print(my_list)               # [1, 2, 3, 4, 5, 6]

my_list = [1, 2, 3]
my_list *= 2
print(my_list)               # [1, 2, 3, 1, 2, 3]
```
# 
- `[Распаковка списка]` - это процесс извлечения элементов из списка и присваивание их переменным.
```
my_list = [1, 2, 3]
a, b, c = my_list

print(a)    # Выведет 1
print(b)    # Выведет 2
print(c)    # Выведет 3
```
- Также, распаковка может быть использована с оператором звездочки (*), который собирает оставшиеся элементы в список:
```
my_list = [1, 2, 3, 4, 5]
first, *rest = my_list

print(first)    # Выведет 1
print(rest)     # Выведет [2, 3, 4, 5]
```
#
- `[Списочные выражения]` - представляют собой синтаксическую конструкцию, которая позволяет создавать списки более компактно и читаемо.
```
[выражение for элемент in итерируемый объект if условие]
- выражение - то, что будет вычислено для каждого элемента,
- элемент - переменная, которая принимает значения из итерируемого объекта,
- итерируемый объект - последовательность, по которой происходит итерация,
- условие (необязательно) - фильтр, который определяет, включать элемент в результат или нет.
```
#
- `[print(*my_list)]` - "распаковка" (unpacking) списка. В данном случае звездочка (*), перед именем списка, распаковывает элементы списка и передает их в функцию print() как отдельные аргументы. Получается вывод списка в одну строку:
```
my_list = [1, 2, 3]
print(*my_list)          # 1, 2, 3
```
# Методы списков

   <details>
  <summary>Методы списков</summary>
  
- `[Методы]` - это специальные функции, применяемые к строковым объектам. Они позволяют выполнять различные операции. Методы списков вызываются через точечную нотацию, например: ` список.метод() `. Списочные методы изменяют оригинальный список а не возвращают новый.
#
 ### 1) `[list.append()]` - Добавляет ОДИН элемент в конец списка.  
```
my_list = [1, 2, 3]
my_list.append(4)

print(my_list)  # [1, 2, 3, 4]
```
#
 ### 2) `[list.extend()]` - Добавляет элементы другой итерируемой последрвательности в конец текущего списка.  
```
first_list = [1, 2, 3]
second_list = [4, 5, 6]

first_list.append(second_list)

print(first_list)  # [1, 2, 3, [4, 5, 6]]
```
#
 ### 3) `[del list[index]]` - Оператор. Удаляет элемент из списка по индексу.
- Оператор `[del]` работает и со срезами (`[ del list[index : index] ]`)
```
first_list = [1, 2, 3]
second_list = [4, 5, 6]

first_list.extend(second_list)

print(first_list)  # [1, 2, 3, 4, 5, 6]
```
#
 ### 4) `[list.split()]` - Строковый метод. Разделяет строку поэлеметно и создаёт из них список. Поумолчанию в качестве разделителя используется пробел. Но можно указать разделитель в скобках метода.
```
my_string = "Раздели эту строку"
split_list = my_string.split(" ")

print(split_list)  # ['Раздели', 'эту', 'строку']
```
#
 ### 5) `[' '.join(list)]` - Строковый метод. Собирает строку из элементов списка. В качестве разделителя, указывается элемент в кавычках перед методом
```
my_list = ['Раздели', 'эту', 'строку']
joined_string = ' '.join(my_list)

print(joined_string)  # 'Раздели эту строку'
```
#
 ### 6) `[list.insert(index, value)]` - Вставляет элемент `[value]` по индексу `[index]`. Вставляет, не заменяет. 
```
my_list = [1, 2, 3, 5]
index = 3
value = 4

my_list.insert(index, value)

print(my_list)  # [1, 2, 3, 4, 5]

```
#
 ### 7) `[list.index(n)]` - Возвращает индекс первого вхождения элемента `[n]` в список. Если элемент не найден, вызывает исключение ValueError.
```
my_list = [1, 2, 3, 4, 5, 3]
element_to_find = 3

index_of_element = my_list.index(element_to_find)

print(index_of_element)  # 2

```
#
 ### 8) `[ list.remove(n) ]` - удаляет первое вхождение элемента `[n]` из списка. Если элемент не найден, вызывает исключение ValueError.
```
my_list = [1, 2, 3, 4, 3, 5]
element_to_remove = 3

my_list.remove(element_to_remove)

print(my_list)  # [1, 2, 4, 3, 5]

```
#
 ### 9) `[list.pop(index)]` - Удаляет элемент по указанному индексу и возвращает его значение. Если индекс не указан, удаляется и возвращается последний элемент списка. Если индекс выходит за границы списка, вызывается исключение IndexError.
```
# Пример 1: Удаление по указанному индексу
my_list = [1, 2, 3, 4, 5]
removed_element = my_list.pop(2)

print(my_list)         # [1, 2, 4, 5]
print(removed_element)  # 3

# Пример 2: Удаление последнего элемента
another_list = [10, 20, 30, 40]
last_element = another_list.pop()

print(another_list)     # [10, 20, 30]
print(last_element)     # 40
```
#
 ### 10) `[list.count(n)]` - Возвращает количество вхождений элемента  `[n]` в список `[list]`.
```
my_list = [1, 2, 3, 3, 4, 3, 5]
count_of_element = my_list.count(3)

print(count_of_element)  # 3
```
#
 ### 11) `[list.reverse()]` - Изменяет порядок элементов в списке на обратный.
```
my_list = [1, 2, 3, 4, 5]
my_list.reverse()

print(my_list)  # [5, 4, 3, 2, 1]
```
#
 ### 12) `[list.clear()]` - удаляет все элементы из списка.
```
my_list = [1, 2, 3, 4, 5]
my_list.clear()

print(my_list)  # []
```
#
 ### 13) `[list.copy()]` - Создаёт поверхностную копию списка. Создает новый список, но не копирует вложенные объекты. Вместо этого, он копирует ссылки на эти объекты. Если в оригинальном списке есть вложенные списки или объекты, они останутся общими для обоих списков. Изменения во вложенных объектах будут видны в обоих списках. 
```
#Пример без вложенных объектов:
original_list = [1, 2, 3, 4, 5]
copied_list = original_list.copy()

print(copied_list)  # [1, 2, 3, 4, 5]

#Пример с вложенным объектом:
list_1 = [1, [2, 3], 4, 5]
list_2 = original_list.copy()

list_2[1][0] = 999

print(list_1)  # [1, [999, 3], 4, 5]
print(list_2)    # [1, [999, 3], 4, 5]

```
#
 ### 14) `[print(*list)]` - Cпособ распаковать элементы списка и передать их в функцию print() как отдельные аргументы для вывода. Это позволяет вывести все элементы списка, разделенные пробелами (по умолчанию), без необходимости использовать цикл или другие итерационные конструкции.
```
my_list = [1, 2, 3, 4, 5]
print(*my_list)  # 1 2 3 4 5
```
#
 ### 15) `[ list.sort() ]` - сортирует элементы списка в порядке возрастания (по умолчанию) или в порядке, определенном с помощью функции-ключа. Изменяет оригинальный список.
```
my_list = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

# Сортировка в порядке возрастания
my_list.sort()
print(my_list)  # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]

# Сортировка в порядке убывания
my_list.sort(reverse=True)
print(my_list)  # [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1]

```
#
 ### 16) `[ sorted(list) ]` - ФУНКЦИЯ которая возвращает новый отсортированный список:
```
my_list = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

# Сортировка в порядке возрастания
sorted_list = sorted(my_list)
print(sorted_list)        # [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
print(my_list)      # [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

# Сортировка в порядке убывания]
reverse_list = sorted(my_list, reverse=True)
print(reverse_list)  # [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1]
print(my_list)      # [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

```
#
  
</details>

- `[  ]`
