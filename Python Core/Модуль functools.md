# Модуль functools

Модуль functools

1. functools - это встроенный модуль в Python, который предоставляет полезные функции высшего порядка для работы с другими функциями.

### Основные функции из functools включают:  

1. functools.reduce: Выполняет кумулятивное вычисление функции на последовательности элементов.  
2. functools.partial: Создаёт новую функцию с частично заданными аргументами.  
3. functools.lru_cache: Декоратор для кэширования результатов функций с целью повышения производительности.  
4. functools.wraps: Декоратор для сохранения метаданных обернутой функции при создании декораторов.  


<details>
  <summary>	Функция partial</summary>

`[partial()]` - позволяет частично использовать функцию, фиксируя некоторые её аргументы. Она создаёт новую функцию, которая уже содержит эти зафиксированные значения и принимает только оставшиеся аргументы.

Синтаксис:

```
functools.partial(func, /, *args, **keywords)
```
- func: Функция, которую нужно частично применить. Это обязательный параметр. 
- *args: Необязательные позиционные аргументы, которые фиксируются для функции func.
- **keywords: Необязательные ключевые аргументы, которые фиксируются для функции func.


<details>
  <summary>Пример</summary>

```
from functools import partial

def multiply(x, y):
    return x * y

# Создаём новую функцию, которая всегда умножает на 2
double = partial(multiply, 2)

# Теперь мы можем использовать double, передавая только второй аргумент
print(double(5))  # Выведет 10
```

1. В функцию `partial`, в качестве первого аргумента, передаётся функция `multiply`. 
2. Вторым аргументом в функцию `partial` передаётся число, которое будет первым аргументом функции `multiply`. 
3. Функция `partial(multiply, 2)` присваивается переменной `double`, которую далее можно вызывать, как возвратную функцию. 
4. Вывод на печать функцию `double`  с аргументом `5`, который встаёт на место второго аргумента функции `multiply`

#

</details>
<details>
  <summary>Атрибуты</summary>

Функция `partial` возвращает partial-объект.   
Созданный объект partial обладает следующими атрибутами:  

- partial.func: исходная функция, которую обёрнули.
- partial.args: аргументы, которые были переданы частично.
- partial.keywords: ключевые аргументы, которые были переданы частично.
```
from functools import partial

def multiply(x, y, z):
    return x * y * z

# Создаём частичную функцию, фиксируя первые два аргумента
partial_func = partial(multiply, 2, 3)

# Используем атрибуты частичной функции
print(partial_func.func)      # Выведет <function multiply at 0x...>
print(partial_func.args)      # Выведет (2, 3)
print(partial_func.keywords)  # Выведет {}
```


#

</details>
<details>
  <summary>Использование partial с именованными аргументами</summary>

```
from functools import partial

# объявляем основную функцию
def greet(greeting, name, punctuation='!', repeat=1):
    return f"{greeting}, {name}{punctuation * repeat}"

# Создаём частичную функцию с фиксированными значениями для аргументов 

shout_greet = partial(greet, punctuation='!!!', repeat=3) 

# Используем частичную функцию 
print(shout_greet('Hello', 'Alice')) # Выведет "Hello, Alice!!!"
```

В этом примере:
* Мы зафиксировали punctuation='!!!' и repeat=3.
* При вызове shout_greet, нам нужно передать только оставшиеся позиционные аргументы greeting и name.


#

</details>
<details>
  <summary>Использование только именованных аргументов</summary>

```
from functools import *

def log_message(level='INFO', message='', timestamp=None):
    return f"{timestamp} [{level}] {message}"

# Создаём частичную функцию с фиксированным уровнем и временем
error_logger = partial(log_message, level='ERROR', timestamp='2024-07-22')

# Используем частичную функцию
print(error_logger(message='Something went wrong'))  # Выведет "2024-07-22 [ERROR] Something went wrong"
```
В этом примере:
* Мы зафиксировали level='ERROR' и timestamp='2024-07-22'.
* При вызове error_logger, нам нужно передать только оставшиеся позиционные и именованные аргументы, такие как message.

#

</details>
<details>
  <summary>Комбинированное использование позиционных и именованных аргументов</summary>

```

from functools import *

# Функция с несколькими аргументами
def configure_device(name, ip, port=80, protocol='http'):
    return f"Configuring {name} at {ip}:{port} using {protocol}"

# Создаём частичную функцию, фиксируя имя устройства и IP
device_setup = partial(configure_device, 'Router', '192.168.1.1', port=443)

# Используем частичную функцию
print(device_setup())  # Выведет "Configuring Router at 192.168.1.1:443 using http"
```
В этом примере:
* Мы зафиксировали name='Router' и ip='192.168.1.1'.
* Мы также зафиксировали port=443.
* При вызове device_setup(), нам нужно передать только оставшийся именованный аргумент protocol, который принимает значение по умолчанию 'http'.

#

</details>
<details>
  <summary>Интересный пример</summary>

За кулисами нам доступна уже реализованная функция send_email(), которая  которая принимает три аргумента в следующем порядке:  

- `name` — имя  
- `email_address` — адрес электронной почты  
- `text` — содержание письма

Функция отправляет письмо пользователю с именем `name` на адрес `email_address` с содержанием `text`  

### Задача №1   

Реализовать функцию `to_Timur()` с помощью функции `partial()`, которая принимает один аргумент:  

`text` — содержание письма  

Функция должна отправлять письмо пользователю с именем Тимур на адрес `timyrik20@beegeek.ru` с содержанием `text`.   

### Задача №2

Реализовать функцию `send_an_invitation()` с помощью функции `partial()`, которая принимает два аргумента в следующем порядке:

- `name` — имя
- `email_address` — адрес электронной почты

Функция должна отправлять письмо на имя name и на адрес email_address со следующим содержанием:  

`Школа BEEGEEK приглашает Вас на новый курс по программированию на языке Python. тутут....`

---------------------------------------------------------------------------------------------

## Реализация:

```
from functools import partial

def to_Timur(text):
    partial_func = partial(send_email, "Тимур", "timyrik20@beegeek.ru")
    return partial_func(text)

def send_an_invitation(name, email_address):
    partial_func = partial(send_email, text='Школа BEEGEEK приглашает Вас на новый курс по программированию на языке Python. тутут....')
    return partial_func(name, email_address)
```

<details>
  <summary>to_Timur()</summary>

1. Что она делает:  

- Создаёт частичную функцию, фиксируя параметры `name` и `email_address` для функции `send_email`.  
- Возвращает результат вызова этой частичной функции с произвольным аргументом `text`.

2. Как она работает:

- `partial(send_email, "Тимур", "timyrik20@beegeek.ru")` создаёт новую функцию, которая будет вызывать `send_email` с зафиксированными аргументами `"Тимур"` и `"timyrik20@beegeek.ru"`, добавляя к ним аргумент text.

- `partial_func(text)` вызывает эту частичную функцию с произвольным аргументом `text`.

#

</details>
<details>
  <summary>send_an_invitation()</summary>

1. Что она делает:

- Создаёт частичную функцию, фиксируя параметр `text` для функции `send_email`.  
- Возвращает результат вызова этой частичной функции с аргументами `name` и `email_address`.  

2. Как она работает:  

- `partial(send_email, text='Школа BEEGEEK приглашает Вас на новый курс по программированию на языке Python. тутут....')` создаёт новую функцию, которая будет вызывать `send_email` с зафиксированным аргументом `text` и добавленными аргументами `name` и `email_address`.
- `partial_func(name, email_address)` вызывает эту частичную функцию с произвольными аргументами `name` и `email_address`.

#

</details>


#

</details>



#

</details>
















<details>
  <summary>Функция update_wrapper()</summary>

Функция update_wrapper()

У partial объектов нет атрибутов  __name__ и __doc__ 
Доступ к этим атрибутам возможен толь через атрибут func:

```
from functools import partial

def multiply(a, b):
    '''Функция перемножает два числа и возвращает вычисленное значение.'''
    return a * b

double = partial(multiply, 2)

print(double.func.__name__)
print(double.func.__doc__)
```

Выводит:

```
multiply
Функция перемножает два числа и возвращает вычисленное значение.
```


С помощью функции update_wrapper() из модуля functools можно скопировать и добавить атрибуты __name__ и __doc__ из исходной функции в partial объект.


```
from functools import partial, update_wrapper

def multiply(a, b):
    '''Функция перемножает два числа и возвращает вычисленное значение.'''
    return a * b

double = partial(multiply, 2)

update_wrapper(double, multiply)   # копируем информацию из функции multiply в partial объект double

print(double.__name__)
print(double.__doc__)
```
 Выводит:

```
multiply
Функция перемножает два числа и возвращает вычисленное значение.
```



#

</details>
<details>
  <summary>Кэширование и мемоизация</summary>

Кэширование – это процесс хранения копий данных в специальном быстром хранилище (кэше), чтобы ускорить доступ к этим данным при повторных запросах.

Кэширование это более широкое понятие. Оно относится к хранению данных или результатов вычислений для ускорения последующих запросов к этим данным. Кэширование может применяться к любым типам данных и на разных уровнях: от аппаратного кэша процессора до кэша веб-браузера.

<details>
  <summary>Кэш</summary>

# Что такое кэш. 

Кэш — это высокоскоростное хранилище данных, используемое для временного сохранения часто используемых или недавно запрошенных данных. Цель кэша — ускорить доступ к этим данным при повторных запросах и уменьшить задержки, связанные с извлечением данных из более медленных хранилищ.  

<details>
  <summary>Основные характеристики кэша</summary>

1. Высокая скорость доступа: Кэш обеспечивает гораздо более быстрое чтение и запись данных по сравнению с основным хранилищем (например, оперативной памятью или жестким диском).
2. Ограниченный объём: Обычно объём кэша ограничен, поэтому данные в нём периодически обновляются. Самые старые или менее используемые данные удаляются, чтобы освободить место для новых данных.
3. Временное хранение: Данные в кэше хранятся временно. Кэш используется для хранения данных, которые могут быстро изменяться или часто запрашиваются.

#

</details>
<details>
  <summary>Примеры кэша</summary>

1. Процессорный кэш: Маленький объём памяти, встроенный в процессор, который хранит копии данных и инструкций, используемых процессором. Это ускоряет выполнение программ.
2. Кэш веб-браузера: Хранит копии веб-страниц, изображений и других ресурсов, чтобы ускорить загрузку страниц при повторных посещениях.
3. Кэш баз данных: Хранит результаты запросов к базе данных, чтобы ускорить последующие запросы с теми же данными.
4. Кэш файловой системы: Операционная система может кэшировать данные с диска в оперативной памяти для быстрого доступа.


#

</details>
<details>
  <summary>Как это работает</summary>

Когда система запрашивает данные, она сначала проверяет кэш:
* Попадание в кэш (cache hit): Если данные уже находятся в кэше, они возвращаются напрямую из него, что значительно ускоряет процесс.
* Промах мимо кэша (cache miss): Если данных в кэше нет, система извлекает их из основного хранилища, помещает их в кэш и возвращает результат. Это занимает больше времени, но подготовляет кэш к будущим запросам тех же данных.


#

</details>


#

</details>


Мемоизация — это частный случай кэширования, который применяется конкретно к функциям. Цель мемоизации — оптимизация функций, которые имеют повторяющиеся вычисления с одинаковыми входными данными.



<details>
  <summary>Основные различия</summary>

1. Контекст применения:
    * Кэширование: Применяется в широком спектре задач, например, кэширование веб-страниц, запросов к базе данных, результатов сложных вычислений и так далее.
    * Мемоизация: Применяется конкретно для оптимизации функций, которые вызываются с одними и теми же параметрами.
2. Цель:
    * Кэширование: Общая цель — уменьшение времени доступа к данным и снижение нагрузки на систему.
    * Мемоизация: Специфическая цель — избежать повторных вычислений одной и той же функции с одинаковыми входными данными.
3. Реализация:
    * Кэширование: Может быть реализовано на разных уровнях (аппаратный, программный, сетевой) и с разными стратегиями (LRU, FIFO, и т.д.).
    * Мемоизация: Обычно реализуется на уровне функций, часто с помощью простых техник, таких как использование словарей или специальных декораторов в Python.

#

</details>
<details>
  <summary>Стратегии кэширования</summary>

Существует несколько различных стратегий, которые можно использовать для удаления элементов из кэша и предотвращения превышения его максимального размера. Пять самых популярных перечислены в таблице ниже: 
```
Стратегия	                       Какую запись удаляем	                Эти записи чаще других используются повторно
First-In, First-Out (FIFO)	       самую старую	                                       новые
Last-In, First-Out (LIFO)	       самую недавнюю	                                       старые
Least Recently Used (LRU)	       которая использовалась наиболее давно	         недавно прочитанные
Most Recently Used (MRU)	       которая использовалась последней	                прочитанные первыми
Least Frequently Used (LFU)	       которая использовалась наиболее редко	       которые использовались часто
```
Стратегия LRU представляет собой метод управления кэшем, в котором данные, которые дольше всего не использовались, считаются наименее ценными, и они удаляются из кэша в первую очередь при необходимости освободить место для новых данных.  

Кэш, реализованный посредством стратегии LRU, упорядочивает элементы в порядке их использования.   

Каждый раз, когда мы обращаемся к записи, алгоритм LRU перемещает ее в верхнюю часть кэша. Таким образом, алгоритм может быстро определить запись, которая дольше всех не использовалась, проверив конец списка.

#

</details>










#

</details>















<details>
  <summary>Null</summary>



#

</details>
