# Тема 46 - Именованные кортежи (namedtuple)

`[collection]` - модуль стандартной библиотеки Python, предоставляющий доступ к дополнительным типам данных (коллекциям), таким как:

   - Именованные кортежи (namedtuple)
   - defaultdict
   - OrderDict
   - Counter
   - ChainMap
   - deque
   - heapq

#

## Именованные кортежи (namedtuple)

`[Именованный кортеж]` - подкласс кортежей (tuple), неизменяемая последовательность, в которой к элементам можно обращаться не только по индексам, но и по именам.

   - Именованые кортежи улучшают читаемость кода
   - Принцип работы поход на функции

## Функция namedtuple()

`[namedtuple()]` - фабричная функция, предназначеная для создания именованных кортежей.

```
from collections import namedtuple

my_point = namedtuple('Point', ['x', 'y'])    # в качестве второго параметра передаем список
point =  my_point(2, 4)
print(my_point)                               # выводит Point(x=2, y=4)
```

   - my_point - переменная, которая ссылается на созданный тип именованного кортежа.
   - 'Point' - строка, которая является именем создаваемого типа именованного кортежа.
   - ['x', 'y'] - список строк, представляющих имена полей в создаваемом типе именованного кортежа.
   - point - переменная, которая содержит экземпляр созданного типа именованного кортежа.

Сигнатура функции:  

`[namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)]`

   - `[typename]` - аргумент представляет собой строку и указывает на имя типа или имени именованного кортежа, который мы хотим создать. Это имя будет использоваться для созданного класса именованного кортежа. Например, если мы указываем typename='Point', то созданный класс будет иметь имя 'Point'.
   - `[filed_names]` - аргумент представляет собой последовательность строк, которая определяет имена полей для именованного кортежа. Поля определяют структуру данных именованного кортежа, и к ним можно будет обращаться по их именам. Например, если мы указываем field_names=['x', 'y'], то созданный именованный кортеж будет иметь поля 'x' и 'y'.
   - `[rename]` - аргумент представляет собой логическое значение (True или False) и указывает, следует ли переименовывать поля, которые не являются допустимыми идентификаторами Python (ключевыми словами). По умолчанию он равен False, что означает, что поля с недопустимыми именами будут вызывать исключение ValueError.

При использование пареметра rename=True, если в поле есть недопустимое значение оно переименуется в порядковый номер в последовательности и символ `[ _ ]` вначале
   - `[defaults]` - аргумент, в котором указывается значение (или последовательность значений) по умолчанию. Если у одного из поля именованного кортежа не указано значение, то используется значение по умолчанию. Если значением по умолчанию указывается последовательность, то в поля без значений они встают с лева на право. По умолчанию defaults = None
   - `[module]` - Этот аргумент представляет собой строку и определяет модуль, в котором будет определен класс именованного кортежа. По умолчанию он равен None, что означает, что класс будет определен в текущем модуле.
#
### В качастве параметра полей именованного кортежа могут использоваться:

   - Списки (namedtuple('Point', ['x', 'y'])
   - Словари (namedtuple('Point', {'x': 0, 'y': 69}))
   - Кортежи (namedtuple('Point', ('x', 'y')))
   - Строки (namedtuple('Point', 'x y')  либо namedtuple('Point', 'x,y')) `разделитель в строке пробел либо запятая`
   - Множества (namedtuple('Point', {'x', 'y'}) `Использование не рекомендуется`

   - Функции map() и filter()
   - Именованые аргументы ()
```
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
point1 = Point(y=10, x=3)                     # именованные аргументы

print(point1)                                 # Point(x=3, y=10)
```
#
### В качастве параметра полей именованного кортежа НЕ могут использоваться:

   - Имена начинающиеся с _
   - Ключевые слова (if, for, else, class, ...)

#
# Атрибуты и Методы именованых кортежей


### Атрибуты _fields и _field_defaults

<details>
   <summary>Атрибут _fields</summary>

`[_fields]` - Содержит кортеж, в котором перечислены имена полей.
```
from collections import namedtuple

Pers = namedtuple('Person', ['name', 'age', 'height'])

tim = Pers('Тимур', 29, 170)

print(tim)              # Person(name='Тимур', age=29, height=170)
print(tim._fields)      # ('name', 'age', 'height')
print(Pers._fields)   # ('name', 'age', 'height')
```
- Обращаться к атрибуту можно как через переменную (tim) так и через тип (Pers)
- Можно создавать новые кортежи, расширяя старые
```
from collections import namedtuple

Pers = namedtuple('Person', ['name', 'age', 'height'])

ExtendedPerson = namedtuple('ExtendedPerson', [*Pers._fields, 'weight'])  # распаковка полей старого кортежа

timur = ExtendedPerson('Тимур', 29, 170, 65)

print(timur)                    # ExtendedPerson(name='Тимур', age=29, height=170, weight=65)
print(ExtendedPerson._fields)   # ('name', 'age', 'height', 'weight')
```
- Можно перебирать поля по их значениям через цикл for и функцию zip()
```
from collections import namedtuple

Pers = namedtuple('Person', ['name', 'age', 'height'])

timur = Pers('Тимур', 29, 170)

for field, value in zip(Pers._fields, timur):
    print(field, '->', value)

###
name -> Тимур
age -> 29
height -> 170

```
 </details>
<details>
   <summary>Атрибут _field_defaults</summary>

`[_field_defaults]` - сопоставляет поля именованного кортежа и проверяет, какие из них содержат значения по умолчанию (defaults). Возвращает словарь:
```
{поле:значение по умолчанию}
```
- Если в именованом кортеже нет полей, которые содержат значения по умолчанию, то возвращвет пустой словарь.
</details>

<details>
   <summary>Метод make()</summary>

`[namedtuple.make(iter_obj)]` - создаёт именованый кортеж из итерируемого объекта, который принимает в качестве аргумента.
```
from collections import namedtuple

Pers = namedtuple('Person', ['name', 'age', 'height'])

timur = Pers._make(['Timur', 29, 170])

print(timur)   # Person(name='Timur', age=29, height=170)
```

- Метод типа а не конкретного экземпляра, соответственно вызывать нужно через тип Именованного кортежа, а не экземпляр класса.

</details>















