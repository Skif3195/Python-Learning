# Обработка исключений try-except

`[Исключение, или ошибка]` - это ситуация, когда выполнение программы прерывается из-за какой-то проблемы или неожиданного условия во время выполнения кода.

`[Ошибка]` - это любое некорректное состояние или действие в программе, которое приводит к нежелательному результату. 
`[Исключение]` - механизм обработки ошибки, который прерывает выполнение программы, при возникновении ошибки. 

- Исключение это специальный объект в Python, который создается в ответ на ошибку во время выполнения программы. Когда возникает ошибка, Python автоматически создает объект-исключение определенного типа и поднимает его (raise), прерывая выполнение кода в текущем контексте.

<details>
  <summary>Общий шаблон инструкции try-except</summary>

```
try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
else:
    # код для случая, если ошибки не было
finally:
    # код, который выполняется всегда
```
</details>

<details>
  <summary>Категории ошибок</summary>  
  
### Выделяют три основные категории ошибок:

<details>
  <summary>Синтаксическая ошибка</summary>  
  
 `[Синтаксическая ошибка]` -  это ошибка, возникающая из-за нарушения синтаксиса языка (Неправильное использование ключевых слов, операторов, скобок или отсутствия необходимых элементов, таких как двоеточия, запятые и т. д.).
 
<details>
  <summary>Основные исключения</summary>

- `SyntaxError`: Это наиболее общее исключение, которое возникает, когда Python не может распознать ваш код из-за ошибки в синтаксисе. Например, забытый двоеточие в конце условия или цикла.
- `IndentationError`: Это возникает, когда отступы в вашем коде не согласованы правильно. Python требует правильного выравнивания для обозначения блоков кода.
- `NameError`: Если вы пытаетесь использовать переменную, которая не была определена, Python вызовет это исключение.
- `TypeError`: Это происходит, когда вы пытаетесь выполнить операцию с объектом несовместимого типа.
- `ZeroDivisionError`: Когда попытка деления на ноль происходит
- `IndentationError`: Ошибка вызвана неправильным форматированием или выравниванием кода.
- `TabError`: Возникает, когда комбинируются табуляция и пробелы для создания отступов в коде.
- `ValueError`: Возникает, когда функция получает аргумент правильного типа, но с недопустимым значением.
</details>

</details>
<details>
  <summary>Ошибки времени выполнения</summary>

`[Ошибки времени выполнения]` - возникает, когда программа сталкивается с непредвиденной ситуацией во время выполнения, которая препятствует ее нормальному завершению (некорректные данные, неправильное использование функций или методов, или недоступность ресурсов).
<details>
  <summary>Основные исключения</summary>

1. `OverflowError`: Возникает, когда результат арифметической операции слишком велик для представления.
2. `IndexError`: Возникает, когда индекс последовательности находится вне допустимого диапазона.
3. `KeyError`: Возникает, когда словарь не содержит указанного ключа.
4. `FileNotFoundError`: Возникает, когда пытаемся открыть файл, который не существует.
5. `AttributeError`: Возникает, когда объект не имеет требуемого атрибута.
6. `ImportError`: Возникает, когда не удается импортировать модуль или его атрибут.
7. `MemoryError`: Возникает, когда недостаточно памяти для выполнения операции.
8. `KeyboardInterrupt`: Возникает, когда пользователь прерывает выполнение программы с клавиатуры (например, нажатием Ctrl+C).
9. `StopIteration`: Возникает, когда метод next() итератора вызывается, но итератор исчерпан.
10. `TypeError`: Возникает, когда операция применяется к объекту несовместимого типа.
11. `AssertionError`: Возникает, когда утверждение assert не проходит.
12. `RuntimeError`: Общее исключение для ошибок времени выполнения, которые не вписываются в другие категории.

</details>

</details>
<details>
  <summary>Логические ошибки</summary>

  `[Логические ошибки]` - (ошибка проектирования или ошибка алгоритма) - это ошибка в логике программы, которая приводит к некорректным результатам, хотя синтаксически и семантически код может быть правильным. Такие ошибки не вызывают исключений, потому что код технически выполняется без ошибок, но результат его работы не соответствует ожидаемому поведению.

</details>

</details>
<details>
  <summary>Коды возврата</summary>
  
- `[Код возврата]` - (код завершения или код возврата из процесса) - это целочисленное значение, возвращаемое программой при ее завершении. Этот код представляет собой способ сообщить вызывающему процессу или системе операций об успешном или неуспешном завершении программы и может содержать информацию о том, были ли выполнены какие-либо операции успешно или нет

<details>
  <summary>Пример</summary>

Метод `find()` используется для поиска подстроки в строке и возвращает индекс первого вхождения этой подстроки в строке. Если подстрока не найдена, метод возвращает -1. 
```
sentence = "Пример строки для поиска"
substring1 = "уют"
substring2 = 'строки'

index1 = sentence.find(substring1)
index2 = sentence.find(substring2)
print(index1) # -1
print(index2) # 7 
```
</details>
</details>
<details>
  <summary>Иерархия исключения</summary>

- `[BaseException]` - базовый класс самого верхнего уровня для всех прочих классов исключений.

- `[Exception]` - азовый класс для большинства встроенных в Python исключений.

- `[issubclass()]` - функция Для проверки родства классов исключений.
```
print(issubclass(IndexError, LookupError)) # True
```
- Если используется несколько блоков `except`, то первыми нужно указывать наиболее конкретные.
```
try:
    nums = [10, 5, 20, 25]
    print(nums[100])
except Exception:
    print('Произошла ошибка!')
except (KeyError, IndexError):
    print('Ошибка связанная с индексом!')
```

- Если нужен доступ к сгенерированному исключению как к объекту, то используется специальный синтаксис.
```
except (KeyError, IndexError) as err:
    pass

err - сгенерированный объект исключения.
```

- `[dir()]` - встроенная функция, позволяет посмотреть все все атрибуты объекта сгенерированного исключения.

<details>
  <summary>Иерархия исключений в Python</summary>

```
BaseException
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- GeneratorExit
 +-- Exception
      +-- StopIteration
      +-- StopAsyncIteration
      +-- ArithmeticError
      |    +-- FloatingPointError
      |    +-- OverflowError
      |    +-- ZeroDivisionError
      +-- AssertionError
      +-- AttributeError
      +-- BufferError
      +-- EOFError
      +-- ImportError
           +-- ModuleNotFoundError
      +-- LookupError
      |    +-- IndexError
      |    +-- KeyError
      +-- MemoryError
      +-- NameError
      |    +-- UnboundLocalError
      +-- OSError
      |    +-- BlockingIOError
      |    +-- ChildProcessError
      |    +-- ConnectionError
      |    |    +-- BrokenPipeError
      |    |    +-- ConnectionAbortedError
      |    |    +-- ConnectionRefusedError
      |    |    +-- ConnectionResetError
      |    +-- FileExistsError
      |    +-- FileNotFoundError
      |    +-- InterruptedError
      |    +-- IsADirectoryError
      |    +-- NotADirectoryError
      |    +-- PermissionError
      |    +-- ProcessLookupError
      |    +-- TimeoutError
      +-- ReferenceError
      +-- RuntimeError
      |    +-- NotImplementedError
      |    +-- RecursionError
      +-- SyntaxError
      |    +-- IndentationError
      |         +-- TabError
      +-- SystemError
      +-- TypeError
      +-- ValueError
      |    +-- UnicodeError
      |         +-- UnicodeDecodeError
      |         +-- UnicodeEncodeError
      |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
           +-- BytesWarning
           +-- ResourceWarning
```
</details>


</details>
<details>
  <summary>try-except</summary>

Конструкция `try-except` используется для обработки исключений в Python.

- `try`: Здесь помещается код, который может вызвать исключение.
- `except`: Если в блоке try произошло исключение, то выполнение кода переходит в блок except. Этот блок содержит код, который будет выполнен при возникновении исключения.
<details>
  <summary>Пример</summary>

```
try:
    result = 10 / 0 # Деление на ноль - ошибка и исключение ZeroDivisionError
except ZeroDivisionError:
    print("Деление на ноль!")
```
В блоке `try` происходит ошибка изза деления на ноль. Эта ошибка вызывает исключение `ZeroDivisionError`, которое обрабатывается в блоке `except`.
</details>
<details>
  <summary>Логика</summary>

Простыми словами:  
  
Конструкция try-except выступает в роли отсеивателя ошибок.  
  
В блок `try` помешается потенциально уязвимый к ошибкам код. 

Либо код отрабатывает без ошибок и программа продолжает работу в штатном режиме.  

Либо происходит ошибка, вызывается исключение, которое обрабатывается в блоке `except`.  

Блок `except` содержет код, который выполняется в случае возникновения ошибки.  

После выполнения кода в блоке `except` программа продолжает свое выполнение.  
</details>
<details>
  <summary>Обработка нескольких исключений</summary>
Если нужно обработать несколько типов исключений, можно использовать несколько блоков except или один блок except с перечислением исключений через запятую:

```
try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
```
Или
```
try:
    # контролируемый код
except (тип_ошибки_1, тип_ошибки_2, ...):
    # обработка тип_ошибки_1 и(или) тип_ошибки_2
```

При обработке нескольких исключений, их нужно обрабатывать в порядке вероятности возникновения.

Первым обрабатывается наиболее конкретное исключение с наибольшей вероятностью возникновения.

Далее более общие исключения с меньшей вероятностью возникновения.

В ином варианте, общие исключения обработаются, затмив тем самым обработку более конкретного исключения.
</details>
<details>
  <summary>Не обязательные блоки else и finally</summary>

- `[else]` - располагается после всех блоков `except`. Выполняется только в том случае, если в боке `try` небыло ошибок.
- `[finaly]` - блок `finaly` располагается в самом конце конструкции `try-except` и выполняется вне зависимости произошла ошибка или нет.

     - Блок finally будет выполнен, даже если блок try содержит break, continue, return
     - При обработке ошибок внутри функции, блок  finally выполняется до инструкции return вне зависимости от их расположения в функции.

 <details>
  <summary>Шаблон использования</summary>

```
try:
    # контролируемый код
except тип_ошибки_1:
    # код обработки ошибки (исключения)
except тип_ошибки_2:
    # код обработки ошибки (исключения)
...
except тип_ошибки_n:
    # код обработки ошибки (исключения)
else:
    # код для случая, если ошибки не было
finally:
    # код, который выполняется всегда
```
</details>


</details>
<details>
  <summary>Исключение как объект</summary>

В Python все исключения являются подклассами (наследниками) базового класса `Exception` и являются объектами-исключений;

Эти объекты создаются при возникновении ошибки и содержат информацию о типе ошибки и контексте, в котором ошибка произошла;

Когда возникает ошибка, Python создает экземпляр соответствующего класса (объект-исключение) и передает его в блок except, где мы можем получить доступ к этому объекту и использовать его для вывода информации о возникшей ошибке;

```
try:
    # Попытка выполнить некорректное деление
    result = 10 / 0
except ZeroDivisionError as e:
    # Обработка исключения сохранения его как объект и вывод на печатьƒ
    print(e)  # division by zero
```


</details>
<details>
  <summary>Оператор raise</summary>


</details>

- `[raise]` - оператор позволяющий вручную возбуждать исключения при определённых условиях.

- Оператор `raise` используется для создания и возбуждения исключений  не входящих в класс `Exception`. Мы создаём при помощи оператора  `raise`  кастомное исключение и обрабатываем его блоком `try-except`.

- Информацию о перехвачены исключениях можно помещать в переменные при помощи ключевого слова `as` 
```
try:
  ...
  raise ...(...)
except Exception as err:
  ...
```
- Ключевое слово as используется в блоке except для связывания информации об исключении с переменной. Таким образом, мы можем использовать эту переменную для доступа к информации об исключении;

#

Конструктор любого исключения принимает переменное количество аргументов; 

Для того чтобы получить указанные значения, мы используем атрибут `args`, который является кортежем;

Синтаксис: 
```
raise [Exception]
raise [Exception(argument)]
raise [Exception(argument)] from [AnotherException]
```
   * `Exception` - класс исключения или объект исключения, которое нужно возбудить.
   * `argument` - это дополнительная информация, которую вы можете передать в исключение. 
   * `from [AnotherException]` - указание на другое исключение, от которого возбуждается текущее исключение (опционально)

1. Во первом варианте оператора raise указывается только название класса исключения.
```
raise ValueError
```
2. Во втором варианте оператора raise указывается экземпляр класса возбуждаемого исключения с аргументами при необходимости. Аргументов может быть несколько.
```
raise ValueError('Oпиcaниe исключения', 'Oпиcaниe исключения', ...)
```
<details>
  <summary>3. Третий вариант требует более детального разбора</summary>
  
`raise [Exception(argument)] from [AnotherException]`  

Конструкция `raise [Exception(argument)] from [AnotherException]` используется в Python для возбуждения исключения и указания на связанное исключение, которое может быть причиной первичного исключения.  

1. `raise [Exception(argument)]`:
    - Это базовая форма оператора raise, где [Exception(argument)] представляет собой класс исключения или объект исключения, которое мы хотим возбудить. [argument] - дополнительная информация об исключении. Например:  
```
raise ValueError("Некорректное значение!")
```
2. `from [AnotherException]`:
    - Это часть конструкции, указывающая на другое исключение, которое стало причиной возникновения текущего исключения. [AnotherException] - класс или объект другого исключения, от которого возникло текущее исключение.  
  
Пример:  

Предположим, у вас есть функция, которая пытается прочитать содержимое файла и выполнить какие-то операции с этим содержимым. Если файл не может быть прочитан, вы хотите вызвать пользовательское исключение FileProcessingError и указать на связанное исключение IOError.

```
def process_file(file_path):
    try:
        with open(file_path, 'r') as file:
            content = file.read()
            # Предположим, что здесь происходят какие-то операции с содержимым файла
            print("Файл успешно обработан.")
            # Ошибка ввода-вывода, такая как невозможность открыть несуществующий файл.
    except IOError as e:
        # Если не удалось прочитать файл, возбудим исключение FileProcessingError и укажем на связанное исключение IOError
        raise FileProcessingError(f"Ошибка обработки файла: {file_path}") from e

# Определяем пользовательское исключение FileProcessingError
class FileProcessingError(Exception):
    pass

# Пример использования функции
file_path = "несуществующий_файл.txt"
try:
    process_file(file_path)
except FileProcessingError as e:
    print(e)

В этом примере, если при попытке прочитать файл возникает исключение IOError,
мы вызываем пользовательское исключение FileProcessingError с дополнительной информацией о файле и указываем на связанное исключение e.
Это позволяет нам сохранить контекст ошибки и предоставить более информативное сообщение об ошибке.
```

</details>
</details>
<details>
  <summary>Пользовательские исключения</summary>

Для создания собственного типа исключения необходимо создать класс, являющийся потомком (наследником) одного из уже существующего типа исключения.  

Самым верным вариантом для наследовния является класс Exception.

```
class NegativeAgeError(Exception):
    pass
```
Приведённый код описывает новый тип исключения с именем NegativeAgeError, который является потомком класса Exception.  

Класс Exception содержит весь необходимый функционал, позволяющий работать с исключениями, поэтому в большинстве случаев достаточно создать пустой класс, который является потомком класса Exception.
```
class NegativeAgeError(Exception):
    pass

try:
    print('Введите свой возраст')
    age = int(input())
    if age < 0:
        raise NegativeAgeError('Возраст не может быть отрицательным')
    print('Ваш возраст равен', age)
except ValueError:
    print('Возраст должен быть числом')
except NegativeAgeError as e:
    print(e)
```

</details>
<details>
  <summary>7. Методики LBYL и EAFP</summary>

При написании программного кода, который может потенциально возбуждать исключения, существуют два основных подхода:

* `LBYL` (Look Before You Leap) — посмотри перед прыжком;
* `EAFP` (Easier to Ask Forgiveness than Permission) — проще извиниться, чем спрашивать разрешение;

Приведенный ниже код

```
data = {'Timur': 29, 'Ivan': 54}

data['Anri'] += 1
```

Приводит к возникновению исключения KeyError, поскольку ключ Anri отсутствует в словаре.
Мы можем исправить такой код двумя способами.

#

`LBYL`:  Перестраховаться и заранее проверить, что все получится. Это идеология LBYL-подхода. Сначала посмотрели, убедились, что все в порядке, только потом сделали.

```
data = {'Timur': 29, 'Ivan': 54}

if 'Anri' in data:
    data['Anri'] += 1
else:
    print('Ключ Anri отсутствует в словаре.')
```

#

`EAFP`: Мы можем описывать только главный алгоритм, рассчитывая, что все будет хорошо. Но при таком подходе необходимо прописать действия с исключениями (иногда разных типов). Это суть подхода EAFP.

```
data = {'Timur': 29, 'Ivan': 54}

try:
    data['Anri'] += 1
except KeyError:
    print('Ключ Anri отсутствует в словаре.')
```


</details>
<details>
  <summary>Оператор assert</summary>

`Оператор assert` – это встроенный оператор используемый для проверки того, является ли заданное утверждение истинным или ложным.  

Если утверждение истинно, то ничего не происходит и выполняется следующая строка кода.  

Если же утверждение ложно, оператор assert останавливает выполнение программы и подобно оператору raise возбуждает исключение AssertionError.

Синтаксис:
```
assert <утверждение>, <Дополнительная к исключению информация>
```
<details>
  <summary>Пример 1</summary>

```
age = 29                # возраст человека

assert age > 0, 'Возраст должен быть положительным числом'
```

Оператор `assert` используется для проверки того, является ли возраст положительным числом.  

В данном случае утверждение `age > 0` истинно, поэтому оператор assert ничего не делает.  

Если бы переменная age имела отрицательное значение, то оператором `assert` было бы возбуждено исключение `AssertionError`
</details>
<details>
  <summary>Пример 2</summary>

```
num1 = 20
num2 = 0

assert num2 != 0, 'Делитель равен нулю.'

print('Частное равно:', num1 / num2)
```

Оператор `assert` используется для проверки того, не равен ли нулю делитель.  

В данном случае утверждение `num2 != 0` ложно, поэтому оператором `assert` будет возбуждено исключение `AssertionError` вместе с добавленным нами сообщением.

Если изменить значение переменной `num2` на `10` и выполнить нашу программу снова, то на этот раз утверждение `num2 != 0` окажется истинным и исключение возбуждено не будет. 

Таким образом, на экран выведется результат деления: `Частное равно: 2.0`
</details>

#

- `Оператор assert` — это средство отладки, которое проверяет утверждение, выступающее в качестве внутренней самопроверки вашей программы;

- `Оператор assert` должен применяться только для того чтобы помогать разработчикам идентифицировать ошибки. Он не является механизмом обработки ошибок;

- `Оператор assert` может быть глобально отключен в настройках интерпретатора;

- `assert` – это именно оператор, а не функция. При использовании assert мы не указываем круглые скобки;

</details>
<details>
  <summary>Список кодов состояния HTTP</summary>

`Код состояния HTTP` (англ. HTTP status code) — часть первой строки ответа сервера при запросах по протоколу HTTP.  

Он представляет собой целое трёхразрядное десятичное число. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа. Примеры:
```
201 Webpage Created
404 Not Found 
507 Insufficient Storage
```

#

<details>
  <summary>1xx: Informational (информационные)</summary>


</details>

- `100 Continue` («продолжайте»)[3];
- `101 Switching Protocols` («переключение протоколов»)[3];
- `102 Processing` («идёт обработка»);
- `103 Early Hints` («ранняя метаинформация»);

<details>
  <summary>2xx: Success (успешно)</summary>


</details>

- `200 OK` («хорошо»);
- `201 Created` («создано»);
- `202 Accepted` («принято»);
- `203 Non-Authoritative Information` («информация не авторитетна»);
- `204 No Content` («нет содержимого»);
- `205 Reset Content` («сбросить содержимое»);
- `206 Partial Content` («частичное содержимое»);
- `207 Multi-Status` («многостатусный»);
- `208 Already Reported` («уже сообщалось»);
- `226 IM Used` («использовано IM»).

<details>
  <summary>3xx: Redirection (перенаправление)</summary>


</details>

- `300 Multiple Choices` («множество выборов»);
- `301 Moved Permanently` («перемещено навсегда»);
- `302 Found` («найдено»);
- `303 See Other` («смотреть другое»);
- `304 Not Modified` («не изменялось»);
- `305 Use Proxy` («использовать прокси»);
- `306 зарезервировано` (код использовался только в ранних спецификациях);
- `307 Temporary Redirect` («временное перенаправление»);
- `308 Permanent Redirect` («постоянное перенаправление»);

<details>
  <summary>4xx: Client Error (ошибка клиента)</summary>


</details>

- `400 Bad Request` («неправильный, некорректный запрос»);
- `401 Unauthorized` («не авторизован»);
- `402 Payment Required` («необходима оплата») — зарезервировано для использования в будущем;
- `403 Forbidden` («запрещено (не уполномочен)»);
- `404 Not Found` («не найдено»);
- `405 Method Not Allowed` («метод не поддерживается»);
- `406 Not Acceptable` («неприемлемо»);
- `407 Proxy Authentication Required` («необходима аутентификация прокси»);
- `408 Request Timeout` («истекло время ожидания»);
- `409 Conflict` («конфликт»);
- `410 Gone` («удалён»);
- `411 Length Required` («необходима длина»);
- `412 Precondition Failed` («условие ложно»);
- `413 Payload Too Large` («полезная нагрузка слишком велика»);
- `414 URI Too Long` («URI слишком длинный»);
- `415 Unsupported Media Type` («неподдерживаемый тип данных»);
- `416 Range Not Satisfiable` («диапазон не достижим»);
- `417 Expectation Failed` («ожидание не оправдалось»);
- `418 I’m a teapot` («я — чайник»);
- `419 Authentication Timeout` (not in RFC 2616) («обычно ошибка проверки CSRF»);
- `421 Misdirected Request`;
- `422 Unprocessable Entity` («необрабатываемый экземпляр»);
- `423 Locked` («заблокировано»);
- `424 Failed Dependency` («невыполненная зависимость»);
- `425 Too Early` («слишком рано»);
- `426 Upgrade Required` («необходимо обновление»);
- `428 Precondition Required` («необходимо предусловие»);
- `429 Too Many Requests` («слишком много запросов»);
- `431 Request Header Fields Too Large` («поля заголовка запроса слишком большие»);
- `449 Retry With` («повторить с»);
- `451 Unavailable For Legal Reasons` («недоступно по юридическим причинам»);
- `499 Client Closed Request` (клиент закрыл соединение);

<details>
  <summary>5xx: Server Error (ошибка сервера)</summary>


</details>

- `500 Internal Server Error` («внутренняя ошибка сервера»);
- `501 Not Implemented` («не реализовано»);
- `502 Bad Gateway` («плохой, ошибочный шлюз»);
- `503 Service Unavailable` («сервис недоступен»);
- `504 Gateway Timeout` («шлюз не отвечает»);
- `505 HTTP Version Not Supported` («версия HTTP не поддерживается»);
- `506 Variant Also Negotiates` («вариант тоже проводит согласование»);
- `507 Insufficient Storage` («переполнение хранилища»);
- `508 Loop Detected` («обнаружено бесконечное перенаправление»);
- `509 Bandwidth Limit Exceeded` («исчерпана пропускная ширина канала»);
- `510 Not Extended` («не расширено»);
- `511 Network Authentication Required` («требуется сетевая аутентификация»);
- `520 Unknown Error` («неизвестная ошибка»);
- `521 Web Server Is Down` («веб-сервер не работает»);
- `522 Connection Timed Out` («соединение не отвечает»);
- `523 Origin Is Unreachable` («источник недоступен»);
- `524 A Timeout Occurred` («время ожидания истекло»);
- `525 SSL Handshake Failed` («квитирование SSL не удалось»);
- `526 Invalid SSL Certificate` («недействительный сертификат SSL»);


</details>
































#
<details>
  <summary></summary>


</details>
