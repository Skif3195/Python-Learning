# Функции +

<details>
  <summary>Встроенные функции</summary>

#
  <details>
  <summary>Математические</summary>

1. abs(n) - возвращает абсолютное значение (модуль) числа n. Аргументом может быть целое, вещественное или комплексное число. 
2. bin() - преобразует целое число в двоичную строку с префиксом 0b (13 -> 0b1101)
3. hex() - преобразует целое число в шестнадцатеричную строку с префиксом 0x (63 -> 0x3f)
4. oct() - преобразует целое число в восьмеричную строку с префиксом 0o (44 -> 0o54)
5. round() - используется для округления чисел. Она принимает два аргумента:

      - number - округляемое число
      - ndigits - кол-во знаков после запятой
      - Округляет в сторону четного числа

6. pow() - используется для возведения чисел в произвольную степень. Она может принимать три аргумента:

      - base — возводимое число
      - - exp — число, являющееся степенью
        - - mod — необязательный аргумент, число, на которое требуется произвести деление с остатком
#

</details>
<details>
  <summary>Типы данных</summary>

1. int() - возвращает целое число (тип int), созданное на основе числа или строки. Также функция имеет необязательный аргумент base — основание системы счисления, по умолчанию равное 10. Вызов без аргументов возвращает 0.

2. float() - возвращает вещественное число (тип float), созданное на основе числа или строки. Вызов без аргументов возвращает 0.0.

3. complex() - используется для создания комплексного числа (тип complex). Она может принимать два аргумента:

      - real — число или строка. Если число, то оно представляет действительную часть комплексного числа
      - - imag — только число, мнимая часть комплексного числа; по умолчанию равняется нулю

`[Функция преобразует строку с записью комплексного числа в комплексное число или возвращает комплексное число со значением переданных аргументов: действительной и мнимой частью. Вызов без аргументов возвращает 0j.`]

4. bool() - возвращает логическое значение переданного объекта. Объект будет возвращать False, если:

      - объект пуст — [], (), {}
      - объект — False
      - объект равен 0
      - объект — None

5. str() - возвращает строковое представление объекта (тип str). Вызов без аргументов возвращает пустую строку.

6. list() - преобразует итерируемый объект в список (тип list). Вызов без аргументов возвращает пустой список.

7. tuple() - преобразует итерируемый объект в кортеж (тип tuple). Вызов без аргументов возвращает пустой кортеж.

8. set() - преобразует итерируемый объект в множество (тип set). Вызов без аргументов возвращает пустое множество.

9. frozenset() - преобразует итерируемый объект в неизменяемое множество (тип frozenset). Вызов без аргументов возвращает пустое неизменяемое множество.

10. dict() - преобразует последовательность пар ключ-значение в словарь (тип dict). Если ключами являются обыкновенные строки, то пары ключ-значение можно указывать в виде именованных аргументов. Вызов без аргументов возвращает пустой словарь.
#

</details>
<details>
  <summary>Строковые функции</summary>

1. ord() - возвращает число, представляющее позицию переданного символа в таблице Unicode.

2. chr() - возвращает символ, чья позиция в таблице Unicode соответствует переданному числу.
#

</details>
<details>
  <summary>Функции работающие с последовательностями</summary>

1. min() - возвращает наименьшее значение элемента итерируемого объекта или самое маленькое из двух или более переданных позиционных аргументов. Также функция min() может принимать два необязательных аргумента

      - key — функция сортировки
      - default — значение по умолчанию, если итерируемый объект окажется пустым

2. max() - возвращает наибольшее значение элемента итерируемого объекта или самое большое из двух или более переданных позиционных аргументов. Также функция min() может принимать два необязательных аргумента

      - key — функция сортировки
      - default — значение по умолчанию, если итерируемый объект окажется пустым

3. len() - возвращает количество элементов в объекте. Объект может быть строкой, списком, кортежем, словарем, множеством или объектом типа range. 

4. sum() - возвращает сумму элементов переданного итерируемого объекта. Также функция имеет необязательный аргумент start — начальное значение для суммы (не может быть строкой), по умолчанию равное нулю.

5. reversed() - возвращает обратный итератор, который перебирает элементы оригинала в обратном порядке.

6. sorted() - возвращает список (тип list) с отсортированными элементами переданного итерируемого объекта. При совпадении значений элементов сохраняется их исходный порядок следования. Также функция имеет два необязательных аргумента:

      - key — функция сортировки
      - reverse — если установлено значение True, то элементы списка сортируются по убыванию

7. all() - возвращает значение True, если все элементы в итерируемом объекте истинны, в противном случае она возвращает значение False.

8. any() - возвращает значение False, если все элементы в итерируемом объекте ложны, в противном случае она возвращает значение True.

9. enumerate() - возвращает итератор кортежей, которые состоят из индекса элемента и самого элемента переданного итерируемого объекта. Также функция имеет необязательный аргумент start —  начальное значение индекса, по умолчанию равное нулю.

10. range() - используется для генерации арифметической последовательности целых чисел с заданным шагом. Возвращает объект типа range. Она может принимать три аргумента:

       - start — начало последовательности (включительно)
       - stop — конец последовательности (не включительно)
       - step — шаг последовательности

11. zip() - возвращает итератор кортежей, который объединяет элементы каждой из переданных последовательностей. Количество передаваемых последовательностей может быть произвольным.
#

</details>
<details>
  <summary>Другие функции</summary>

1. id() - возвращает уникальный идентификатор для указанного объекта.
2. input() - ввод пользовательских данных из консоли.
3. isinstance() - проверяет принадлежность объекта к заданному типу
4. open() - открывает файл для чтения или записи.
5. print() - вывод пользовательских данных в текстовый поток.
6. type() - возвращает тип данных, к которому относится переданный объект.
7. hasattr(obj, atr_name) - встроенная функция, которая проверяет, есть ли у объекта указанный атрибут. Возвращает True/False. Принимает два аргумента - проверяемую функци, атрибут наличие которого проверяется. 

----------------------------------------------------------------------------------------------------------------------------------------------------------------------
7. calleble() - проверяет, является ли переданный объект вызываемым. Это означает, что можно ли вызвать объект как функцию. Функция callable() возвращает True, если объект вызываем (функция, метод или объект с реализованным методом __call__), и False в противном случае.

8. hasattr(obj, atr_name) - проверяет, имеет ли объект определённый атрибут.  

9. hash() - используется для вычисления хеш-значения (хеш-кода) для  неизменяемого (хэшируемого ) объекта. Хеш-значение - это числовое значение фиксированной длины, которое является уникальным для каждого уникального объекта.

10. help() - используется для получения документации по указанному модулю, функции или другому объекту. Вызов без аргументов запускает интерактивную справочную систему в консоли интерпретатора (для выхода используйте quit)

11. repr() - возвращает "официальное», понятное интерпретатору, строковое представление объекта, которое может быть использовано для воссоздания этого объекта с помощью функции eval(), если это возможно.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
<details>
  <summary>Функция eval</summary>
6. eval() -  Выполняет одну строку кода Python, которая должна быть выражением, переданным в качестве аргумента в виде строки. 

      - возвращает результат вычисления переданного ей выражения, и этот результат может быть сохранен для дальнейшего использования.
      - Выполнение кода через eval() может быть медленнее, чем напрямую написанный код, потому что строка сначала должна быть интерпретирована и выполнена во время выполнения программы.

`[Для выполнения строки-выражения, функция eval() совершает следующие шаги:`]
1. Парсит (parse) выражение
2. Компилирует (compile) выражение в байт-код
3. Вычисляет (evaluate) значение выражения
4. Возвращает (return) результат вычисления

`[Выражения, передаваемые в качестве аргумента функции eval(), имеют доступ ко всем встроенным функциям Python`]

```
expression1 = "print('Привет из функции eval()’)».   #Привет из функции eval()
expression2 = "len([1, 1, 1, 1, 1])».   #5
```
   - Выражения, передаваемые в качестве аргумента функции eval(), имеют доступ ко всем локальным и глобальным переменным.
   - Не все языковые конструкции являются выражениями (expression). Операторами, которые нельзя использовать в качестве выражений, являются, например, while, for, if, def, import, class, raise и т.д.

`[С помощью функции eval() можно парсить объекты, то есть преобразовывать из строки в реальные Python объекты.`]

```
list_data = eval("['Python', 'C#', 'Java']")
tuple_data = eval('(1, 2, 3, 4, 5)')
dict_data = eval("{1: 'January', 2: 'February'}")

print(type(list_data), len(list_data)).  #<class 'list'> 3
print(type(tuple_data), max(tuple_data)).  #<class 'tuple'> 5
print(type(dict_data), dict_data[2]).  #<class 'dict'> February
```
</details>
<details>
  <summary>Функция exec</summary>

7. exec() - Выполняет блок кода Python, который может включать несколько строк и не ограничен одним выражением. Не возвращает значение (всегда возвращает None). Но позволяет обращаться к участкам выполненного кода. 

      - Выполнение кода: exec() принимает строку с кодом Python и выполняет её.
      - Возвращаемое значение: exec() всегда возвращает None.
      - Доступ к переменным: Переменные и функции, созданные или изменённые в ходе выполнения кода, остаются доступными в текущем пространстве имён или в указанных глобальных и локальных пространствах имён.

`[На exec() нельзя ссылаться как на переменную. 
 exec() — это функция, которая выполняет код. Она не сохраняет сам код или результат выполнения кода в виде объекта, к которому можно было бы обратиться позднее.
 Вместо этого, результаты выполнения кода сохраняются в текущем пространстве имен.`]

Синтаксис:
```
exec(source, globals=None, locals=None, /)
```

Где:

   - source - строка с программным кодом для выполнения.
   - lobals (необязательный) - словарь, представляющий глобальное пространство имен.
   - locals (необязательный) - словарь, представляющий локальное пространство имен.

```
globals_dict = {'x': 10}

exec('print(x)', globals_dict)  # Выполнение в пользовательском глобальном пространстве имен

locals_dict = {'y': 20}

exec('print(y)', {}, locals_dict)  # Выполнение в пользовательском локальном пространстве имен
```


В первом случае переданный словарь globals_dict определяется как глобальное пространство имен, а во втором случае словарь locals_dict определяется как локальное пространство имен.
Иными словами, в первом случае код, переданный в exec(), будет выполняться в контексте, где globals_dict будет интерпретирован как глобальное пространство имен, а второй случай определяет локальное пространство имен для выполнения переданного кода.

#

</details>

#

</details>



</details>













<details>
  <summary>Функции как объекты</summary>

1. Функции Являются объектами
2. Функции можно записывать в переменную
```
def my_func():
    return 17

input = my_func
num = input()
print(num)
```

3. Кастомная функция может принимать произвольное кол-во аргументов 
```
def nop(*rest, **kwargs):
    pass                               # заглушка, функция ничего не делает

print = nop
print('Привет', 'мир')
print('Stepik', 'Beegeek', 'Python', sep='*', end='')
print('Stepik', 'Beegeek', 'Python', delimeter='-', endline='\n')
```
- Оригинальная функция print() принимает не любые именованные аргументы, а только небольшой список
- функция nop() же (а значит, и переопределенная функция print()) — абсолютно любые.


4. Функции можно хранить в структурах даных:

```
def avg(nums):
    return sum(nums)/len(nums)

funcs = [len, sum, min, avg]

primes = [2, 3, 5, 7, 11]

for func in funcs:
    print(func(primes))
```
Выводит:
```
5
28
2
5.6
```


5. Можно использовать методы, как обычные функции. Для этого нужно указать название типа, затем точку и название метода: type.method
```
text = 'hello'
numbers = [1, 2, 3]

text_upper = str.upper(text)
list.append(numbers, 4)

print(text_upper)
print(numbers)
```
Выведет:
```
HELLO
[1, 2, 3, 4]
```
#

</details>
<details>
  <summary>Атрибуты функций</summary>

В Python функции являются объектами, и как у любого объекта, у них могут быть атрибуты. 

- Атрибут функции — это переменная, которая прикрепляется к объекту функции и может использоваться для хранения дополнительной информации, связанной с функцией.

1. Инициализация атрибута функции: Атрибут функции инициализируется сразу после определения функции. Это нужно для того, чтобы атрибут был доступен до первого вызова функции.
3. Использование атрибута внутри функции:

- Внутри функции атрибут используется так же, как любой другой объект того же типа (список, строка, множество и т.д.).

<details>
  <summary>Пример с множеством (set)</summary>

```
def polynom(x):
    n = x ** 2 + 1
    polynom.values.add(n)  # Используем метод add для добавления элемента в множество
    return n

# Инициализация атрибута values как пустого множества
polynom.values = set()

# Вызов функции и использование атрибута
print(polynom(5))        # Выводит: 26
print(polynom.values)    # Выводит: {26}

print(polynom(3))        # Выводит: 10
print(polynom.values)    # Выводит: {10, 26}
```
#

</details>

<details>
  <summary>Пример со списком (list)</summary>

```
def add_to_list(x):
    add_to_list.values.append(x)  # Используем метод append для добавления элемента в список

# Инициализация атрибута values как пустого списка
add_to_list.values = []

# Вызов функции и использование атрибута
add_to_list(5)
print(add_to_list.values)  # Выводит: [5]

add_to_list(3)
print(add_to_list.values)  # Выводит: [5, 3]
```
#

</details>

<details>
  <summary>Пошаговый разбор</summary>

Пошаговый разбор
1. Определение функции: Определяем функцию, которая будет использовать атрибут.
2. Инициализация атрибута: Инициализируем атрибут функции сразу после ее определения, указывая тип объекта, который будет храниться в атрибуте (например, set, list, str).
3. Использование атрибута внутри функции: Внутри функции работаем с атрибутом так, как будто это стандартный объект соответствующего типа, используя его методы и операции.
4. В качестве атрибута может использоваться другая функция:
```
def main_function(x):
    result = x ** 2 + 1
    print("Main function result:", result)
    if hasattr(main_function, 'helper_function'):
        main_function.helper_function(result)
    return result

def helper_function(y):
    print("Helper function received:", y)

# Присваиваем другую функцию как атрибут
main_function.helper_function = helper_function

# Вызов основной функции
main_function(5)
```
#

</details>

 
`[hasattr()]` - встроенная функция, которая проверяет, есть ли у объекта указанный атрибут. Возвращает True/False. Принимает два аргумента - проверяемую функци, атрибут наличие которого проверяется. 

#

</details>
<details>
  <summary>Атрибуты __name__, __doc__, __defaults__</summary>

`[Четыре важных атрибута функций]`

   * __name__ — имя функции
   *  __doc__ — строка документации
   *  __defaults__ — кортеж с аргументами по умолчанию
   *  __dict__ - У объектов функций есть дополнительный атрибут __dict__, являющийся словарем и использующийся для динамического наделения функций дополнительным функционалом.


`[Устанавливать и получать значения из данного атрибута можно, используя два синтаксиса]`

   - В стиле словаря: func.__dict__['attr'] = value
   - Через точечную нотацию: func.attr = value 

<details>
  <summary>Пример</summary>

```
def func(name, language='Python', year=1992):
    pass

print(func.__name__)          # имя функции
print(func.__doc__)           # строка документации
print(func.__defaults__)      # кортеж с аргументами по умолчанию
```
Выведет:
```
func
None
('Python', 1992)
```

#

</details>

`[Строка документации (docstring) — это строковый литерал, который расположен сразу за объявлением функции]`

<details>
  <summary>Пример</summary>
  
Приведенный ниже код:
```
print(abs.__doc__)
print(str.lower.__doc__)
```
выводит:

Return the absolute value of the argument.
Return a copy of the string converted to lowercase.

#

</details>

`[Основное назначение комментариев – пояснить что делает код, как он работает]`

`[Основное назначение строк документации – описать в целом для чего предназначен объект, какие аргументы принимает, и что возвращает]`

<details>
  <summary>Пример</summary>

Приведенный ниже код: 
```
def square(n):
    '''Принимает число и возвращает его квадрат.'''
    return n**2

def average(*args):
    '''Принимает несколько чисел и возвращает их среднее арифметическое значение.'''
    return sum(args)/len(args)

print(square.__doc__)
print(average.__doc__)
```

Выводит:
Принимает число и возвращает его квадрат.
Принимает несколько чисел и возвращает их среднее арифметическое значение.

#

</details>

`[Мы можем использовать как тройные двойные кавычки """, так и тройные одинарные кавычки ''' для создания строк документации. Тройные кавычки используются для многострочных строк.]`  
`[В строку документации попадает только первая строка после определения функции (инструкция def)]`

При описании строки документации обычно описывают типы принимаемых аргументов и возвращаемое значение функции. 

Рассмотрим функцию multiplier(), которая принимает два числа (int, float) и возвращает их произведение.

```
def multiplier(num1, num2):
    """Перемножает два числа и возвращает их произведение.
    :параметр num1: int, float, первое число в произведении;
    :параметр num2: int, float, второе число в произведении;
    :возвращаемое значение: int, float, произведение двух чисел.
    """
    return num1 * num2
```

#

</details>

#














<details>
  <summary>Вложенные функции</summary>

#

  Вложенная функция просто означает, что одна функция определена внутри другой функции. Вот основные особенности вложенных функций:
  
  1. Область видимости: Вложенная функция имеет доступ ко всем переменным, которые были определены в области видимости внешней функции.
  
  2. Локальные переменные: Внутри вложенной функции можно определять свои собственные локальные переменные, которые не будут доступны за пределами этой функции.

  3. Область действия: Вложенная функция существует только внутри внешней функции и не доступна извне, если её не возвращают в качестве результата выполнения внешней функции.

<details>
  <summary>Пример №1</summary>

#

Пример кода:
  
```
def outer_function():
    # Внешняя функция определяет переменную x
    x = 10
    
    # Вложенная функция, которая имеет доступ к переменной x из внешней функции
    def inner_function():
        # Выводит значение x из внешней функции
        print(f"Значение x из внешней функции: {x}")
    
    # Вызов вложенной функции
    inner_function()

# Вызов внешней функции
outer_function()
```

### Пошаговый разбор:  

1. Определение внешней функции outer_function:

      - Функция outer_function определяет переменную x и присваивает ей значение 10.

2. Определение вложенной функции inner_function:

      - Вложенная функция inner_function определена внутри функции outer_function.
      - Она использует значение переменной x из области видимости внешней функции outer_function.
        
3. Вызов вложенной функции inner_function:

      - Внешняя функция outer_function непосредственно вызывает вложенную функцию inner_function.

4. Вывод значения x из внешней функции:

      - Когда inner_function вызывается внутри outer_function, она выводит значение переменной x с помощью print(f"Значение x из внешней функции: {x}").

5. Вызов внешней функции outer_function:

      - После определения функции outer_function, мы вызываем её, например, с помощью outer_function().

6. Результат выполнения:

      - При вызове outer_function(), вложенная функция inner_function сразу же вызывается внутри неё и выводит значение переменной x, которое равно 10.

#

</details>
<details>
  <summary>Пример №2</summary>

#

Пример кода:

```
def speak(text):
    def whisper(t):                      # Вложенная функция whisper
        return t.lower() + '...'         # Возвращает текст в нижнем регистре с добавлением троеточия
        
    return whisper(text)                 # Вызываем whisper с аргументом text и возвращаем результат

print(speak('Hello, World'))
```

Пошаговый разбор:  

1. Определение внешней функции speak:

      - Функция speak принимает один аргумент text.

2. Определение вложенной функции whisper:

      - Вложенная функция whisper определена внутри функции speak.
      - Она принимает аргумент t и возвращает t.lower() + '...', то есть преобразует текст t в нижний регистр и добавляет троеточие в конце.

3. Возвращение результата из вложенной функции:

      - Внешняя функция speak вызывает вложенную функцию whisper с аргументом text (это значение переданное при вызове speak) и возвращает результат этого вызова.


4. Вызов функции speak с аргументом 'Hello, World':

      - Когда мы вызываем speak('Hello, World'), аргумент 'Hello, World' передается в функцию speak.

5. Выполнение вложенной функции whisper:

      - Внутри функции speak, whisper('Hello, World') вызывается с аргументом 'Hello, World'.
      - Вложенная функция whisper преобразует 'Hello, World' в 'hello, world...' (нижний регистр с троеточием).
  
6. Возврат результата:

      - Результат выполнения whisper('Hello, World') (то есть 'hello, world...') возвращается из функции speak.

7. Вывод результата:

      - Функция print выводит результат выполнения speak('Hello, World'), который равен 'hello, world...'.

Таким образом, вложенная функция whisper используется для обработки текста внутри внешней функции speak, а затем результат этой обработки возвращается и выводится на экран.

#

</details>


#

</details>
<details>
  <summary>Замыкание</summary>
  
#
  
`[Замыкание]` — это функция, которая запоминает и сохраняет в своём состоянии значения переменных из окружающей области видимости, даже после того как эта область завершила своё выполнение. Это позволяет функции использовать и изменять эти переменные при последующих вызовах, обеспечивая сохранение контекста выполнения.

<details>
  <summary>Шаблонный пример замыкания</summary>
  
 Пример кода:
  
```
def up_func(n):                 # Определение внешней функции с параметром n
    def dawn_func(m):       # Определение внутренней функции с параметром m
        return m * n               # Внутренняя функция использует параметр n из внешней функции
    return dawn_func         # Внешняя функция возвращает внутреннюю (создание замыкания)

example = up_func(2)      # Вызов внешней функции с аргументом 2, создание замыкания
result = example(5)          # Вызов внутренней функции через замыкание с аргументом 5
print(result)                       # Вывод результата: 10

```
Подробное объяснение шаблона
1. Определение внешней функции up_func:
    * Функция up_func принимает один аргумент n.
2. Определение внутренней функции dawn_func:
    * Внутри up_func определяется функция dawn_func, которая принимает аргумент m и использует n из внешней функции.
3. Создание замыкания:
    * Внутренняя функция dawn_func "замыкается" на значение n, переданное в up_func.
    * Когда up_func возвращает dawn_func, создается замыкание, которое сохраняет значение n.
4. Присваивание замыкания переменной:
    * example = up_func(2) создает замыкание, где n равно 2, и присваивает это замыкание переменной example.
5. Вызов замыкания:
    * Когда вызывается example(5), фактически вызывается функция dawn_func, которая использует сохраненное значение n (2) и переданное значение m (5).
6. Результат выполнения:
    * Внутренняя функция выполняет умножение m * n (5 * 2) и возвращает результат (10).

#

</details>
<details>
  <summary>Другой пример закрепления</summary>

Пример кода:

```
def greeting_creator(greeting):          # Определение внешней функции с параметром greeting
    def greet(name):                     # Определение внутренней функции с параметром name
        return f"{greeting}, {name}!"    # Внутренняя функция использует параметр greeting из внешней функции
    return greet                         # Внешняя функция возвращает внутреннюю (создание замыкания)

# Вызов внешней функции с аргументом 'Hello', через присвоение ее переменной создание замыкания
hello_greeter = greeting_creator('Hello')

# Вызов внешней функции с аргументом 'Goodbye', через присвоение ее переменной создание замыкания
goodbye_greeter = greeting_creator('Goodbye')

# Вызов внутренней функции через замыкание с аргументом 'Alice'
print(hello_greeter("Alice"))   # Output: Hello, Alice!

# Вызов внутренней функции через замыкание с аргументом 'Bob'
print(goodbye_greeter("Bob"))   # Output: Goodbye, Bob!

```

Пояснение шагов с обновленными комментариями
1. Определение внешней функции:
    * def greeting_creator(greeting): — Определяет внешнюю функцию greeting_creator, которая принимает один аргумент greeting.
2. Определение внутренней функции:
    * def greet(name): — Определяет внутреннюю функцию greet, которая принимает один аргумент name.
    * return f"{greeting}, {name}!" — Внутренняя функция использует переменную greeting из внешней функции для создания строки приветствия.
3. Возвращение внутренней функции:
    * return greet — Внешняя функция возвращает внутреннюю функцию greet, создавая замыкание, которое сохраняет значение greeting.
4. Создание замыканий через присвоение переменным:
    * hello_greeter = greeting_creator('Hello') — Вызов внешней функции с аргументом 'Hello' и присвоение результата переменной, создавая замыкание с сохранением значения greeting = 'Hello'.
    * goodbye_greeter = greeting_creator('Goodbye') — Вызов внешней функции с аргументом 'Goodbye' и присвоение результата переменной, создавая замыкание с сохранением значения greeting = 'Goodbye'.
5. Вызов замыканий:
    * hello_greeter("Alice") — Вызов внутренней функции через замыкание с аргументом name = 'Alice', результатом будет строка 'Hello, Alice!'.
    * goodbye_greeter("Bob") — Вызов внутренней функции через замыкание с аргументом name = 'Bob', результатом будет строка 'Goodbye, Bob!'.

#

</details>

#

</details>
<details>
  <summary>nonlocal</summary>
  
#

При поиске переменной с указанным именем приоритет (правило разрешения имен) следующий:

   - сначала ищем локальную переменную
   - если не нашли локальную, ищем нелокальную
   - если не нашли нелокальную, ищем глобальную
   - и в самом конце — встроенную в язык

Промежуточная область видимости, которая доступна вложенным функциям, называется нелокальной.

#

`[nonlocal]` - ключевое слово, котороеиспользуется для указания того, что переменная, которая обычно находится в области видимости родительской функции и является локальной для неё, может быть изменена вложенной функцией."

- `[nonlocal]` - позволяет изменить 'родительскую переменную' для использования ее в внутренней функции.

<details>
  <summary>Пример</summary>

```
def outer_function():
    x = 10
    
    def inner_function():
        nonlocal x
        x += 5
        print(f"Значение x после изменения во вложенной функции: {x}")
    
    inner_function()
    print(f"Значение x во внешней функции после вызова вложенной: {x}")

outer_function()

Выводит:

Значение x после изменения во вложенной функции: 15
Значение x во внешней функции после вызова вложенной: 15
```

### Пошаговое объяснение:

1. Определение внешней функции outer_function:

      - Внутри outer_function определяется переменная x и присваивается ей значение 10.

2. Определение вложенной функции inner_function:

      - Вложенная функция inner_function имеет доступ к переменной x из внешней функции outer_function.

3. Использование nonlocal:

      - В строке nonlocal x указывается, что переменная x, которая будет использоваться внутри inner_function, на самом деле находится в области видимости родительской функции (outer_function). Это позволяет вложенной функции изменять значение переменной x.

4. Изменение переменной и вывод результатов:

      - Вложенная функция увеличивает значение x на 5 (x += 5).
      - После изменения значения x, выводится его новое значение внутри вложенной функции.
      - Затем выводится значение x во внешней функции после вызова вложенной функции.

5. Результат выполнения:

      - При вызове outer_function(), вложенная функция inner_function успешно изменяет значение переменной x из внешней функции, что демонстрирует работу ключевого слова nonlocal.  
  
  
Таким образом, nonlocal позволяет расширить доступ к переменным из родительской функции для вложенной функции и изменять их значения внутри вложенной функции

</details>

#

</details>


























<details>
  <summary>Null</summary>


</details>





