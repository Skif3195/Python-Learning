# Декораторы

`[Декоратор]` — это функция, которая принимает другую функцию в качестве аргумента, выполняет с ней какие-то действия, и возвращает новую функцию, которая обычно вызывает оригинальную функцию, но с добавленным поведением.

## Проще говоря: декораторы обертывают функцию, изменяя ее поведение.

<details>
  <summary>Декорирование</summary>


### Ручное декорирование  

При ручном декорировании ты явно вызываешь декоратор и сохраняешь результат в переменную. Это позволяет сохранить доступ к исходной функции.

```
def sample_decorator(func):          # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

def say():
    print('Привет Мир!')

decorated_say = sample_decorator(say) # декорируем функцию вручную

say()           # вызов недекорированной функции
decorated_say() # вызов декорированной функции
```

### Декорирование через нотацию @

Нотация `@` позволяет применять декоратор к функции, идущей сразу после этой нотации.  
Когда ты используешь `@decorator_name` перед определением функции, это эквивалентно оборачиванию этой функции в декоратор.

```
def sample_decorator(func):          # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

@sample_decorator                    # декорируем функцию
def say():
    print('Привет Мир!')

say()
```

`@sample_decorator`  эквивалентно `say = sample_decorator(say)`

Когда ты вызываешь `say()`, фактически вызывается функция `wrapper`, определенная внутри декоратора `sample_decorator`.

#

Можно применять несколько декораторов к одной функции через нотацию `[@]`, указная их подряд над функцией. 
 ```
@bold
@italic
def greet():
    return 'Hello world!'

print(greet())
```

Декораторы применяются в порядке `снизу вверх`

#

### Декорирование функций с аргументами  

Когда функция, которую ты декорируешь, принимает аргументы, декоратор должен быть способен обрабатывать эти аргументы.   

Это достигается с помощью `*args` и `**kwargs`.

```
def bold(func):
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'

    return wrapper
```

Как это работает:
1. Определение декоратора: Декоратор `bold` принимает функцию func в качестве аргумента.
2. Обертка: Внутренняя функция `wrapper` принимает произвольное количество позиционных и именованных аргументов с помощью `*args` и `**kwargs`.
3. Вызов функции: `wrapper` вызывает оригинальную функцию `func` с этими аргументами и добавляет `HTML-тег <b>` вокруг результата.


```
@bold
def greet(name):
    return f'Hello, {name}!'

print(greet('Igor'))
```
#

### Декоратор с возвратом значения  


Возврат значения из декорируемой функции происходит через возврат значения внутренней функции декоратора. 


1. `[Создание вложенной функции]:` Внутри декоратора создается вложенная функция (обычно называемая wrapper), которая будет оборачивать оригинальную функцию.
2. `[Вызов оригинальной функции]:` Вложенная функция вызывает оригинальную функцию с переданными аргументами.
3. `[Обработка результата]:` Вложенная функция обрабатывает результат, возвращаемый оригинальной функцией.
4. `[Возврат задекорированного значения]:` Вложенная функция возвращает обработанное значение.
5. `[Возврат вложенной функции]:` Декоратор возвращает вложенную функцию, которая теперь обернута в дополнительную логику.

```
def talk(func):
    def wrapper(*args, **kwargs):  # Вложенная функция принимает *args и **kwargs
        dash = '-' * 15
        result = func(*args, **kwargs)  # Вызов оригинальной функции с переданными аргументами
        return dash + '\n' + result + '\n' + dash  # Обработка и возврат задекорированного значения
    return wrapper  # Возвращение вложенной функции

@talk
def greet(name):
    return f'Hello, {name}!'

print(greet('Igor'))
```

### Пошаговое объяснение:

   1. `[Декоратор talk]:` Определяем функцию `talk`, которая принимает функцию `func` в качестве аргумента.
   2. `[Вложенная функция wrapper]:` Внутри talk определяем wrapper, которая принимает *args и **kwargs.
   3. `[Создание разделителей]`: Внутри wrapper создаем строку dash, состоящую из 15 тире.
   4. `[Вызов func]`: Внутри wrapper вызываем оригинальную функцию func с аргументами *args и **kwargs и сохраняем результат в переменной result.
   5. `[Обработка результата]`: Внутри wrapper обрабатываем результат, добавляя разделители до и после результата.
   6. `[Возврат результата]`: Вложенная функция wrapper возвращает обработанное значение.
   7. `[Возврат wrapper]`: Декоратор talk возвращает функцию wrapper.

### Итог:  

Когда ты вызываешь `greet('Igor')`, фактически вызывается функция `wrapper`, которая:
1. Создает строку `dash` из 15 тире.
2. Вызывает оригинальную функцию `greet` с аргументом `Igor` и сохраняет результат в `result`.
3. Обрабатывает результат, добавляя разделители до и после результата.
4. Возвращает обработанное значение.

Таким образом, декорированная функция возвращает задекорированное значение, созданное внутренней функцией декоратора.

</details>




<details>
  <summary>Атрибуты __name__  и __doc__ </summary>

`[Атрибут __name__ ]`- содержит строку с именем функции
`[Атрибут __doc__ ]`- используется для хранения строки документации (docstring) функции, метода, класса или модуля. Атрибут для кастового создания документации, для кастомных функций.   

Для создания документации для атрибута, нужно в первой строке тела функции, прописать какой-либо текст в кавычках. Именно этот текст и будет хранить  атрибут __doc__. 


<details>
  <summary>Ручное присваивание атрибутов</summary>

```
def bold(func):
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'
    wrapper.__name__ = func.__name__
    wrapper.__doc__ = func.__doc__
    return wrapper

@bold
def greet(name):
    '''Функция приветствия пользователя.'''
    return f'Hello {name}!'

print(greet.__name__)
print(greet.__doc__)
```

wrapper.__name__ = func.__name__
* Присваиваем обёртке wrapper атрибут __name__ оригинальной функции func, чтобы сохранить имя функции.

wrapper.__doc__ = func.__doc__
* Присваиваем обёртке wrapper атрибут __doc__ оригинальной функции func, чтобы сохранить документацию функции.

#

</details>

<details>
  <summary>Авто присваивание - functools.wraps</summary>

functools.wraps — это удобная функция, которая делает то же самое, что и update_wrapper, но также возвращает саму обёртку, что упрощает использование:


```
import functools

def bold(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'
    return wrapper

@bold
def greet(name):
    '''Функция приветствие пользователя.'''
    return f'Hello {name}!'

print(greet.__name__)
print(greet.__doc__)
```


в данном примере мы применяем декоратор wraps через нотацию @ к функции-обёртке.

#

</details>


#

</details>
















Шаблон декоратора общего назначения

```
import functools

def decorator(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # Что-то выполняется до вызова декорируемой функции
        value = func(*args, **kwargs)
        # декорируется возвращаемое значение функции
        # или что-то выполняется после вызова декорируемой функции
        return value
    return wrapper
```



<details>
  <summary>Декоратор измерения времени работы функции</summary>


Следующий декоратор измеряет и выводит время выполнения декорируемой функции. Декоратор вычисляет время непосредственно перед запуском функции и сразу после ее завершения и выводит разницу подсчитанных времен.

```
import functools, time

def timer(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start = time.perf_counter()
        val = func(*args, **kwargs)
        end = time.perf_counter()
        work_time = end - start
        print(f'Время выполнения {func.__name__}: {round(work_time, 4)} сек.')
        return val
    return wrapper
```
#

</details>

<details>
  <summary>Декоратор отслеживания количества вызовов функции</summary>


 Создадим декоратор, который подсчитывает, сколько раз вызывается функция. Для сохранения состояния счетчика будем использовать пользовательский атрибут функции.

```
import functools

def counter(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        wrapper.num += 1
        print(f'Вызов {func.__name__}: {wrapper.num}')
        val = func(*args, **kwargs)
        return val
    wrapper.num = 0
    return wrapper
```
#

</details>

<details>
  <summary>Декоратор замедления времени выполнения функции</summary>


import functools
import time

def slow_down(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        time.sleep(1)
        return func(*args, **kwargs)
    return wrapper

@slow_down
def countdown(number):
    if number < 1:
        print('Конец!')
    else:
        print(number)
        countdown(number - 1)
        
countdown(5)

#

</details>


<details>
  <summary>Декораторы с Аргументами</summary>


Для того чтобы создать декоратор, принимающий аргументы, необходимо добавить еще один уровень вложенности, то есть создать функцию, которая возвращает нужный декоратор:

```
def print_symbols(symbol, length):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(symbol * length)
            return func(*args, **kwargs)
        return wrapper
    return decorator
```

Функция print_symbols() на первый взгляд может показаться декоратором, но на самом деле таковым не является. Это обычная функция, которая принимает аргументы symbol и length, а затем возвращает декоратор. В свою очередь, он декорирует функции add(), mult() и diff().

```
@print_symbols('*', 30)
def add(a, b):
    return a + b

@print_symbols('-', 10)
def mult(a, b):
    return a * b

@print_symbols('=', 40)
def diff(a, b):
    return a - b

print(add(3, 9))
print(mult(10, 20))
print(diff(100, 1))

Выведет:  ******************************
12
----------
200
========================================
99
```

#

</details>



ДЕКОРАТОР - ФУНКЦИЯ, КОТОРАЯ ПРИНИМАЕТ ФУНКЦИЮ В КАЧЕСТВЕ АРГУМЕНТА И ВОЗВРАЩАЕТ ФУНКЦИЮ.  

<details>
  <summary>Декоратор delayed - Задержка выполнения программы</summary>

Декорирование рекурсивной функции обратного отсчёта:  ```
import functools
import time

def delayed(delay=2):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            print(f'Спим {delay} сек.')
            time.sleep(delay)
            value = func(*args, **kwargs)
            return value
        return wrapper
    return decorator

@delayed(1)
def countdown(number):
    if number < 1:
        print('Конец!')
    else:
        print(number)
        countdown(number - 1)
        
countdown(5)
```
Выведет:  ```
Спим 1 сек.
5
Спим 1 сек.
4
Спим 1 сек.
3
Спим 1 сек.
2
Спим 1 сек.
1
Спим 1 сек.
Конец!
```

#

</details>

<details>
  <summary>Декоратор timer - время выполнения функции</summary>

Для более точного подсчета декоратор принимает аргумент iters, который задает количество измерений.

```
import functools, time

def timer(iters):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            total = 0
            for i in range(iters):
                start = time.perf_counter()
                value = func(*args, **kwargs)
                end = time.perf_counter()
                total += end - start
            print(f'Среднее время выполнения {func.__name__}: {round(total/iters, 4)} сек.')
            return value
        return wrapper
    return decorator



@timer(iters=3)
def sleep(n):
    time.sleep(n)

res2 = sleep(4)

print(f'Результат функции sleep = {res2}')
```
 Выведет:

```
Среднее время выполнения sleep: 4.0079 сек.
Результат функции sleep = None
```
#

</details>

<details>
  <summary>Декоратор repeater - вызов декорированной функции переданное кол-во раз</summary>

```
import functools

def repeater(repeat):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for i in range(1, repeat + 1):
                print(f'{i}-й запуск функции.')
                value = func(*args, **kwargs)
            return value
        return wrapper
    return decorator


@repeater(5)
def beegeek():
    print('beegeek')

beegeek()

```
Выводит:

```
1-й запуск функции.
beegeek
2-й запуск функции.
beegeek
3-й запуск функции.
beegeek
4-й запуск функции.
beegeek
5-й запуск функции.
beegeek
```

#

</details>



























































