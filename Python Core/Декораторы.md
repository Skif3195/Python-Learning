# Декораторы

`[Декоратор]` — это функция, которая принимает другую функцию в качестве аргумента, выполняет с ней какие-то действия, и возвращает новую функцию, которая обычно вызывает оригинальную функцию, но с добавленным поведением.

## Проще говоря: декораторы обертывают функцию, изменяя ее поведение.


### Ручное декорирование  

При ручном декорировании ты явно вызываешь декоратор и сохраняешь результат в переменную. Это позволяет сохранить доступ к исходной функции.

```
def sample_decorator(func):          # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

def say():
    print('Привет Мир!')

decorated_say = sample_decorator(say) # декорируем функцию вручную

say()           # вызов недекорированной функции
decorated_say() # вызов декорированной функции
```

### Декорирование через нотацию @

Нотация `@` позволяет применять декоратор к функции, идущей сразу после этой нотации.  
Когда ты используешь `@decorator_name` перед определением функции, это эквивалентно оборачиванию этой функции в декоратор.

```
def sample_decorator(func):          # определяем декоратор
    def wrapper():
        print('Начало функции')
        func()
        print('Конец функции')
    return wrapper

@sample_decorator                    # декорируем функцию
def say():
    print('Привет Мир!')

say()
```

`@sample_decorator`  эквивалентно `say = sample_decorator(say)`

Когда ты вызываешь `say()`, фактически вызывается функция `wrapper`, определенная внутри декоратора `sample_decorator`.

#

Можно применять несколько декораторов к одной функции через нотацию `[@]`, указная их подряд над функцией. 
 ```
@bold
@italic
def greet():
    return 'Hello world!'

print(greet())
```

Декораторы применяются в порядке `снизу вверх`

#

### Декорирование функций с аргументами  

Когда функция, которую ты декорируешь, принимает аргументы, декоратор должен быть способен обрабатывать эти аргументы.   

Это достигается с помощью `*args` и `**kwargs`.

```
def bold(func):
    def wrapper(*args, **kwargs):
        return '<b>' + func(*args, **kwargs) + '</b>'

    return wrapper
```

Как это работает:
1. Определение декоратора: Декоратор `bold` принимает функцию func в качестве аргумента.
2. Обертка: Внутренняя функция `wrapper` принимает произвольное количество позиционных и именованных аргументов с помощью `*args` и `**kwargs`.
3. Вызов функции: `wrapper` вызывает оригинальную функцию `func` с этими аргументами и добавляет `HTML-тег <b>` вокруг результата.


```
@bold
def greet(name):
    return f'Hello, {name}!'

print(greet('Igor'))
```
#

### Декоратор с возвратом значения  


Возврат значения из декорируемой функции происходит через возврат значения внутренней функции декоратора. 


1. `[Создание вложенной функции]:` Внутри декоратора создается вложенная функция (обычно называемая wrapper), которая будет оборачивать оригинальную функцию.
2. `[Вызов оригинальной функции]:` Вложенная функция вызывает оригинальную функцию с переданными аргументами.
3. `[Обработка результата]:` Вложенная функция обрабатывает результат, возвращаемый оригинальной функцией.
4. `[Возврат задекорированного значения]:` Вложенная функция возвращает обработанное значение.
5. `[Возврат вложенной функции]:` Декоратор возвращает вложенную функцию, которая теперь обернута в дополнительную логику.

```
def talk(func):
    def wrapper(*args, **kwargs):  # Вложенная функция принимает *args и **kwargs
        dash = '-' * 15
        result = func(*args, **kwargs)  # Вызов оригинальной функции с переданными аргументами
        return dash + '\n' + result + '\n' + dash  # Обработка и возврат задекорированного значения
    return wrapper  # Возвращение вложенной функции

@talk
def greet(name):
    return f'Hello, {name}!'

print(greet('Igor'))
```

### Пошаговое объяснение:

   1. `[Декоратор talk]:` Определяем функцию `talk`, которая принимает функцию `func` в качестве аргумента.
   2. `[Вложенная функция wrapper]:` Внутри talk определяем wrapper, которая принимает *args и **kwargs.
   3. `[Создание разделителей]`: Внутри wrapper создаем строку dash, состоящую из 15 тире.
   4. `[Вызов func]`: Внутри wrapper вызываем оригинальную функцию func с аргументами *args и **kwargs и сохраняем результат в переменной result.
   5. `[Обработка результата]`: Внутри wrapper обрабатываем результат, добавляя разделители до и после результата.
   6. `[Возврат результата]`: Вложенная функция wrapper возвращает обработанное значение.
   7. `[Возврат wrapper]`: Декоратор talk возвращает функцию wrapper.

### Итог:  

Когда ты вызываешь `greet('Igor')`, фактически вызывается функция `wrapper`, которая:
1. Создает строку `dash` из 15 тире.
2. Вызывает оригинальную функцию `greet` с аргументом `Igor` и сохраняет результат в `result`.
3. Обрабатывает результат, добавляя разделители до и после результата.
4. Возвращает обработанное значение.

Таким образом, декорированная функция возвращает задекорированное значение, созданное внутренней функцией декоратора.



















