# Аннотации типов


<details>
  <summary>Типизация языков программирования</summary>  
  
#
Типизация языков программирования ‌—‌ ‌это‌ ‌то,‌ ‌как‌ ‌различные‌ ‌языки‌ ‌распознают‌ ‌типы‌ ‌данных.  

‌Языки‌ ‌программирования‌ ‌бывают‌:

<details>
  <summary>1) Нетипизированными‌ ‌(Бестиповыми)</summary>
  
`[Бестиповые языки программирования]` — это те, в которых отсутствует система типов данных. Операции над данными выполняются без учета типов.  

`Преимущества:`

   - Позволяет писать на предельно низком уровне, без припятствий со стороны компилятор (интерпретатор).
   - Получаемый код обычно более эффективен.
   - Прозрачность инструкций, код простой и понятный.

`Недостатки:`  

   - Отсутствие проверок: любые бессмысленные действия будут считаться совершенно нормальными.
   - Низкий уровень абстракции: работа со сложным типом данных не отличается от работы с простыми типами данных.


Нетипизированные языки: Assembler, Forth, Brainfuck

#

</details>
<details>
  <summary>2) Типизированными‌</summary>

`[Типизированные языки программирования]` — это языки, в которых данные имеют определённый тип, который может быть проверен в процессе компиляции или исполнения программы.  

   - Типы определяют, какие операции могут быть выполнены с данными и как они могут взаимодействовать.

#

Типизированные языки разделяются еще на несколько категорий:  

<details>
  <summary>Статическая и динамическая типизация</summary>

`[Статическая типизация]` — это механизм в языках программирования, при котором типы данных явно указываются на этапе компиляции, до начала выполнения программы. Когда тип переменной определён, его уже нельзя изменить на другой тип. 

`Преимущества статической типизации:` 

   - Проверки типов происходят только один раз — на этапе компиляции
   - Скорость выполнения
   - Отсеивание вариантов, заведомо не подходящих по типу.

Пример языков статической типизации: C, Java, C#, Kotlin, Scala, GO

#

`[Динамическая типизация]` — это механизм в языках программирования, при котором типы переменных определяются во время выполнения программы. В таких языках переменная может принимать значения различных типов в разные моменты времени, и типы данных могут изменяться динамически в ходе выполнения программы.  
  

`Преимущества динамической типизации:`

   - Простота создания универсальных коллекций.
   - Удобство описания алгоритмов (например сортировка может производиться с любыпи типами данных).

Пример языков динамической типизации: Python, JavaScript, Ruby, Julia

#

</details>
<details>
  <summary>Строгая и нестрогая типизация</summary>

`[Нестрогая]` — это типизация, при которой происходит автоматическое преобразование типов (или приведение типов). Это означает, что операции между различными типами данных выполняются автоматически, даже если эти типы обычно не совместимы.

Пример на JS:  

```
5‌‌ ‌‌+‌‌ ‌‌'6'‌;‌ ‌‌            //‌ ‌'56'‌ ‌
4‌‌ ‌‌*‌‌ ‌‌'3'‌;‌ ‌‌            //‌ ‌12‌ ‌
2‌‌ ‌‌+‌‌ ‌‌true‌;‌‌            //‌ ‌3‌ ‌
false‌‌ ‌-‌ ‌‌4‌;‌‌           //‌ ‌-4‌
```

`Преимущества слабой типизации:`  

1. Простота написания кода.
2. Гибкость: код, может работать с разными типами данных.
3. Краткость записи

Примеры языков слабой типизации: C, JavaScript, Visual Basic, PHP

#

`[Сильная (или строгая) типизация`] — это типизация, при которой любые операции над переменными различных типов требуют явного преобразования типов, и попытка выполнить операцию с несовместимыми типами вызовет ошибку.

Пример на Python: 

```
x = 10       # x — целое число
y = "5"      # y — строка

z = x + int(y)  # явное преобразование строки в целое число
```

`Преимущества сильной типизации:`  

1. Код более предсказуемый и очевидный.
2. Низкая вероятность ошибок, связанных с неожиданными преобразованиями типов.
3. Полный контроль над типами данных.
5. Скорость выполнения программы. 

Примеры языков сильной типизации: Java, Python, Haskell, Lisp


#

</details>
<details>
  <summary>Явная и неявная типизация</summary>

`[Явная типизация]` - означает, что тип каждой переменной указывается явно при её объявлении.  

Например:

```
# Явная типизация в C++
int x = 5;
```

`Преимущества явной типизации:`  

- Наличие у каждой функции сигнатуры (например int add(int, int)) позволяет без проблем определить, что функция делает.

Пример языков с явной типизацией: C++, D, C#, Java

#

`[Неявная типизация]` - означает, что тип переменной определяется автоматически на основе значения, которое ей присваивается.  

Например:

```
# Неявная типизация в Python
x = 5
```

`Преимущества неявной типизации:`  

- Сокращение записи: запись `def add(x, y)` короче, чем `int add( int x, int y)`
- Устойчивость к изменениям: `если в функции временная переменная была того же типа, что и входной аргумент, то при изменении типа входного аргумента не нужно будет изменять тип временной переменной`

Пример языков с явной типизацией: Python, PHP, Lua, JavaScript


#

</details>
<details>
  <summary>Примеры типизации конкретных языков</summary>

`[Python]` - это язык с динамической, строгой и неявной типизацией.  
`[JavaScript]` - это язык с динамической, нестрогой и неявной типизацией.  
`[PHP]` - это язык с динамической, нестрогой и неявной типизацией.  
`[Java]` - это язык со статической, строгой и явной типизацией.  
`[C]` - это язык со статической, строгой и явной типизацией.  
`[C++]` - это язык со статической, строгой и явной типизацией.  
`[C# ]` - это язык со статической, строгой и явной типизацией.  
`[GO]` - это язык со статической, строгой и явной типизацией.  
`[Ruby]` - это язык с динамической, строгой и неявной типизацией.  
`[Haskel]` - это язык со статической, строгой и явной типизацией.  

#

</details>


#

</details>

#

</details>













<details>
  <summary>Аннотации типов</summary>

Аннотация типов  - способ указать ожидаемые типы аргументов и возвращаемого значения функции. Используются для статического анализа и улучшения читаемости кода. 

<details>
  <summary>Базовый пример</summary>

```
def greet(name: str) -> str:
    return f"Hello, {name}"

result = greet("Tim")
print(result)
```

`name: str` указывает , что функция `greet` принимает аргумент name, который должен быть строкой (`тип str`).   
`-> str` - говорит о том, что функция возвращает строку (`тип str`).
Можно использовать и любые другие базовые (не являющиеся коллекциями) типы в Python:  `int`, `float`,  `bool`,  `str`,  `NoneType`.
#

</details>
<details>
  <summary>Пример 1</summary>

Функция print_hello() принимает два аргумента типа str и bool. Ожидается что она возвращает значение None (так как функция невозвратная)

```
def print_hello(name: str, upper: bool = False) -> None:
    if upper:
        name = name.upper()
    print(f'Hello, {name}')
```

#

</details>
<details>
  <summary>Пример 2</summary>
Функция avg() принимает три аргумента типа int и возвращает значение float:
```
def avg(num1: int, num2: int, num3: int) -> float:
    return (num1 + num2 + num3) / 3
```

#

</details>

<details>
  <summary>Разновидности Аннотаций</summary>


<details>
  <summary>1. Аннотации типов при объявлении переменных</summary>

#
```
name: str = "Игорь"
age: int = 28
is_developer: bool = True
```
#

</details>
<details>
  <summary>2. Аннотации типов в функциях</summary>

#
```
def greet(name: str) -> str:
    return f"Hello, {name}"
```
При аннотации значения по умолчанию его тип должен предшествовать значению по умолчанию `[ def greet(name: str = 'world') -> str]`

#

</details>
<details>
  <summary>3. Использование аннотаций типов с None</summary>

#
```
def print_hello(name: str, upper: bool = False) -> None:
    if upper:
        name = name.upper()
    print(f'Hello, {name}')
```

`[-> None]` - указывает на то, что функция ничего не возвращает (print а нe return)

#

</details>
<details>
  <summary>4.Аннотации типов для переменных в любом месте кода</summary>

#
```
user_name: str  # Переменная объявлена, но значение еще не присвоено
user_name = "Игорь"

user_age: int = 28  # Аннотация и присваивание значения
```

#

</details>
<details>
  <summary>5.Аннотации типов в циклах и условиях</summary>

#
```
for i in range(10):
    count: int = i  # Аннотация внутри цикла
    print(count)

if some_condition:
    result: str = "Условие выполнено"
else:
    result: str = "Условие не выполнено"
```

#

</details>

#

</details>

<details>
  <summary>Аннотация типов коллекций - Модуль typing</summary>

#
Аннотации типов коллекций в Python используются для указания типов элементов внутри коллекций, таких как списки, словари, множества и кортежи.

`[Модуль typing в Python]` предоставляет средства для аннотирования типов в коде. Он используется для указания типов переменных, аргументов функций, возвращаемых значений и других элементов программы. Это помогает улучшить читаемость кода, делает его более самодокументированным и облегчает статическую проверку типов с использованием таких инструментов, как mypy




<details>
  <summary>Основные типы коллекций и их аннотации</summary>

<details>
  <summary>1. Списки (List)</summary>

```
from typing import List

names: List[str] = ["Игорь", "Анна", "Мария"]
```

В функциях:

```
from typing import List

def sum_numbers(numbers: List[int]) -> int:
    return sum(numbers)

# Пример использования
numbers = [1, 2, 3, 4, 5]
result = sum_numbers(numbers)
print(f"Сумма чисел: {result}")  # Вывод: Сумма чисел: 15
```

#

</details>

<details>
  <summary>2. Словари (Dict)</summary>

```
from typing import Dict

age_by_name: Dict[str, int] = {"Игорь": 28, "Анна": 25, "Мария": 30}
```

В функциях:

```
from typing import Dict

def get_age(people: Dict[str, int], name: str) -> int:
    return people.get(name, 0)

# Пример использования
people_ages = {"Игорь": 28, "Анна": 25}
age = get_age(people_ages, "Игорь")
print(f"Возраст Игоря: {age}")  # Вывод: Возраст Игоря: 28

```

#

</details>

<details>
  <summary>3. Множества (Set)</summary>

```
from typing import Set

unique_names: Set[str] = {"Игорь", "Анна", "Мария"}
```

В функциях:

```
from typing import Set

def unique_numbers(numbers: List[int]) -> Set[int]:
    return set(numbers)

# Пример использования
numbers = [1, 2, 2, 3, 4, 4, 5]
unique = unique_numbers(numbers)
print(f"Уникальные числа: {unique}")  # Вывод: Уникальные числа: {1, 2, 3, 4, 5}
```

#

</details>

<details>
  <summary>4. Кортежи (Tuple)</summary>

```
from typing import Tuple

coordinates: Tuple[int, int] = (10, 20)
person_info: Tuple[str, int, bool] = ("Игорь", 28, True)
```

В функциях:

```
from typing import Tuple

def get_person_info() -> Tuple[str, int, bool]:
    return ("Игорь", 28, True)

# Пример использования
name, age, is_developer = get_person_info()
print(f"Имя: {name}, Возраст: {age}, Разработчик: {is_developer}")  # Вывод: Имя: Игорь, Возраст: 28, Разработчик: True
```

#

</details>

<details>
  <summary>5. Общие коллекции (Sequence, Mapping) </summary>

`[Sequence]` — это тип,  для всех типов данных, которые можно перебирать по порядку, таких как списки, кортежи и строки.  

`[Mapping`] — это общее слово для всех типов данных, которые сопоставляют ключи и значения, как словари.

```
from typing import Sequence, Mapping

names_sequence: Sequence[str] = ["Игорь", "Анна", "Мария"]
age_mapping: Mapping[str, int] = {"Игорь": 28, "Анна": 25, "Мария": 30}
```

Sequence в функциях:

```
from typing import Sequence

def process_sequence(seq: Sequence[int]) -> int:
    return sum(seq)

# Пример использования
list_of_numbers = [1, 2, 3, 4]  # список
tuple_of_numbers = (1, 2, 3, 4)  # кортеж

print(process_sequence(list_of_numbers))  # Вывод: 10
print(process_sequence(tuple_of_numbers))  # Вывод: 10
```

Mapping в функциях:

```
from typing import Mapping

def get_keys(mapping: Mapping[str, int]) -> list:
    return list(mapping.keys())

# Пример использования
dict_of_ages = {"Игорь": 28, "Анна": 25}

keys = get_keys(dict_of_ages)
print(keys)  # Вывод: ['Игорь', 'Анна']
```

#

</details>

<details>
  <summary>6. Использования в функциях</summary>


```
from typing import List, Dict, Tuple

def process_names(names: List[str]) -> int:
    return len(names)

def get_ages() -> Dict[str, int]:
    return {"Игорь": 28, "Анна": 25}

def get_coordinates() -> Tuple[int, int]:
    return (10, 20)
```

#

</details>

<details>
  <summary>7. Вложенные коллекции</summary>

```
from typing import List, Dict

# Список словарей
list_of_dicts: List[Dict[str, int]] = [
    {"Игорь": 28},
    {"Анна": 25}
]

# Словарь, где ключ - строка, а значение - список строк
dict_of_lists: Dict[str, List[str]] = {
    "friends": ["Игорь", "Анна", "Мария"],
    "family": ["Олег", "Татьяна"]
}
```

В функциях:

```
from typing import List, Dict

def get_students_grades() -> List[Dict[str, int]]:
    return [
        {"name": "Игорь", "grade": 90},
        {"name": "Анна", "grade": 85}
    ]

# Пример использования
students_grades = get_students_grades()
for student in students_grades:
    print(f"Студент: {student['name']}, Оценка: {student['grade']}")  
    # Вывод: Студент: Игорь, Оценка: 90
    # Вывод: Студент: Анна, Оценка: 85
```

#

</details>

<details>
  <summary>8. Аннотации типов с Union и Optional</summary>

`[Union]` - Для указания нескольких возможных типов.
`[Optional]` - Для указания None-значений

```
from typing import List, Union, Optional

# Список, содержащий как строки, так и числа
mixed_list: List[Union[str, int]] = ["Игорь", 28, "Анна", 25]

# Список строк, который может быть None
optional_list: Optional[List[str]] = None
```

Union в функциях:

```
from typing import Union

def to_string(value: Union[int, float, bool]) -> str:
    return str(value)

# Пример использования
print(to_string(42))       # Вывод: "42"
print(to_string(3.14))     # Вывод: "3.14"
print(to_string(True))     # Вывод: "True"
```

Optional в функциях:

```
from typing import Optional

def find_person(name: str) -> Optional[Dict[str, Any]]:
    people = {
        "Игорь": {"age": 28, "is_developer": True},
        "Анна": {"age": 25, "is_developer": False}
    }
    return people.get(name)

# Пример использования
person = find_person("Игорь")
if person:
    print(person)  # Вывод: {'age': 28, 'is_developer': True}
else:
    print("Человек не найден")
```

#

</details>

<details>
  <summary>9. Аннотации типов с Any</summary>

`[Any]` - используется, когда переменная или аргумент функции может быть любого типа. Это полезно в ситуациях, когда тип данных не определён или может меняться.

```
from typing import Any, List

# Переменная, которая может быть любого типа
variable: Any = "Изначально строка"
variable = 42  # Теперь это целое число
variable = [1, 2, 3]  # Теперь это список

# Функция, принимающая аргумент любого типа и возвращающая список значений любого типа
def append_to_list(item: Any, lst: List[Any]) -> List[Any]:
    lst.append(item)
    return lst

my_list: List[Any] = [1, "string", True]
my_list = append_to_list(3.14, my_list)
print(my_list)  # Вывод: [1, 'string', True, 3.14]
```

Пример использования `Any` в функции:

```
from typing import Any, Dict

def get_value(data: Dict[str, Any], key: str) -> Any:
    return data.get(key)

data: Dict[str, Any] = {"name": "Игорь", "age": 28, "is_developer": True}
name = get_value(data, "name")
age = get_value(data, "age")
is_developer = get_value(data, "is_developer")

print(f"Name: {name}, Age: {age}, Is Developer: {is_developer}")
```

#

</details>

<details>
  <summary>10.  Аннотации типов с NoReturn</summary>

`[NoReturn]` - используется для аннотации функций, которые никогда не возвращают значение, потому что они всегда вызывают исключение или завершение работы программы.

```
from typing import NoReturn

# Функция, которая завершает выполнение программы с сообщением об ошибке
def terminate_with_error(message: str) -> NoReturn:
    raise SystemExit(message)

# Функция, которая вызывает исключение и никогда не возвращает значение
def raise_exception() -> NoReturn:
    raise RuntimeError("Это исключение всегда вызывается")

try:
    raise_exception()
except RuntimeError as e:
    print(f"Поймано исключение: {e}")

# Вызов terminate_with_error завершит выполнение программы с указанным сообщением
# terminate_with_error("Ошибка: завершение программы")

```

Пример использования `NoReturn` в функции:

```
from typing import NoReturn

def handle_critical_error(error_message: str) -> NoReturn:
    print(f"Critical error: {error_message}")
    raise SystemExit(1)

def perform_critical_task(condition: bool) -> None:
    if not condition:
        handle_critical_error("Condition not met. Exiting.")
    print("Critical task performed successfully.")

# Пример вызова функции, которая может вызвать критическую ошибку
try:
    perform_critical_task(False)
except SystemExit as e:
    print(f"System exited with code: {e.code}")
```

#












#

</details>











#

</details>

#

</details>

#


</details>


<details>
  <summary>Атрибут __annotation__</summary>

`[Атрибут __annotations__ ]` - хранит аннотации типов для переменных, аргументов функций и возвращаемых значений. Возвращает словарь, в котором ключём является имя аннотированного элемента, значением указанный тип. Последней паре в словаре всегда идёт возвращаемое значение ('return': <class 'str'>)


<details>
  <summary>Использование с функциями</summary>

```
def avg(num1: int, num2: int, num3: int) -> float:
    return (num1 + num2 + num3) / 3

print(avg.__annotations__)

# Вывод:: {'num1': <class 'int'>, 'num2': <class 'int'>, 'num3': <class 'int'>, 'return': <class 'float'>}
```

#

</details>

<details>
  <summary>Использование с переменными</summary>

```
x: int = 5
y: str = "hello"

# Доступ к аннотациям типов переменных
print(__annotations__)  

# Вывод: {'x': <class 'int'>, 'y': <class 'str'>}
```

#

</details>

<details>
  <summary>Использование с классами</summary>

```
class Person:
    name: str
    age: int

    def __init__(self, name: str, age: int) -> None:
        self.name = name
        self.age = age

# Доступ к аннотациям типов атрибутов класса
print(Person.__annotations__)  
# Вывод: {'name': <class 'str'>, 'age': <class 'int'>}

# Доступ к аннотациям типов метода
print(Person.__init__.__annotations__)  

# Вывод: {'name': <class 'str'>, 'age': <class 'int'>, 'return': <class 'NoneType'>}
```

#

</details>



#

</details>
<details>
  <summary>Тайп-чеккеры</summary>

`[Тайп-чеккер (type checker)]` — это инструмент или программа, которая выполняет статическую проверку типов в исходном коде программы на языке программирования. Он анализирует аннотации типов, указанные разработчиком, и проверяет соответствие типов переменных, аргументов функций, возвращаемых значений и других элементов кода указанным типам.


<details>
  <summary>Основные задачи тайп-чеккера</summary>

1. Проверка согласованности типов: Убеждается, что типы данных, используемые в коде, соответствуют ожидаемым типам, указанным в аннотациях.

2. Поиск потенциальных ошибок: Выявление мест, где типы данных могут быть некорректно использованы или несоответствующим образом изменены.

3. Улучшение читаемости и надежности кода: Аннотации типов и статическая проверка помогают делать код более понятным, документированным и менее подверженным ошибкам в типах данных.

#

</details>

<details>
  <summary>mypy</summary>


`[mypy]` — это инструмент как инструмент статической проверки типов в Python, основанный на аннотациях типов, которые добавляются непосредственно в исходный код программы.

<details>
  <summary>Шаги работы mypy</summary>

1. Чтение исходного кода
Mypy анализирует исходный код программы на Python. Он читает аннотации типов, которые разработчики добавляют к переменным, аргументам функций, возвращаемым значениям и другим элементам кода.

2. Анализ типов
На основе аннотаций типов mypy строит внутреннее представление типов для каждого элемента кода. Это позволяет инструменту понять, какие типы данных ожидаются и как они должны взаимодействовать друг с другом в процессе выполнения программы.

3. Проверка соответствия типов
Mypy проверяет каждое место использования переменных, аргументов функций и возвращаемых значений на соответствие указанным типам. Если тип данных не соответствует ожидаемому, mypy генерирует предупреждение или ошибку. Например, если функция должна возвращать строку, но возвращаемое значение имеет тип целого числа, mypy выдаст сообщение об ошибке.

4. Выдача отчета
После завершения анализа mypy предоставляет отчет о найденных ошибках или потенциальных проблемах с типами данных в коде. Этот отчет помогает разработчикам исправить ошибки до того, как они возникнут в процессе выполнения программы.

#

</details>

Пример использования:

```
# Пример кода с аннотациями типов для mypy
def greet(name: str) -> str:
    return f"Hello, {name}"

def calculate_sum(values: list[int]) -> int:
    return sum(values)

# Вызов mypy для анализа
# В консоли выполняем команду: mypy имя_файла.py
```

#

</details>



#

</details>


























<details>
  <summary>Null</summary>



#

</details>












